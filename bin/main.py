# Generated by Haxe 4.2.0
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import sys as python_lib_Sys
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import random as python_lib_Random
import traceback as python_lib_Traceback


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'



class BinaryTreeMaze:
    _hx_class_name = "BinaryTreeMaze"
    __slots__ = ()
    _hx_statics = ["on"]

    @staticmethod
    def on(grid):
        cell = GridIterator(grid)
        while cell.hasNext():
            cell1 = cell.next()
            neighbors = []
            if (cell1.north is not None):
                x = cell1.north
                neighbors.append(x)
            if (cell1.east is not None):
                x1 = cell1.east
                neighbors.append(x1)
            x2 = len(neighbors)
            neighbor = python_internal_ArrayImpl._get(neighbors, (0 if ((x2 <= 0)) else int((python_lib_Random.random() * x2))))
            if (neighbor is not None):
                cell1.link(neighbor)


class Cell:
    _hx_class_name = "Cell"
    __slots__ = ("row", "column", "north", "south", "east", "west", "_links")
    _hx_fields = ["row", "column", "north", "south", "east", "west", "_links"]
    _hx_methods = ["link", "unlink", "links", "neighbors", "isLinked", "distances"]

    def __init__(self,row,column):
        self.west = None
        self.east = None
        self.south = None
        self.north = None
        self.row = row
        self.column = column
        self._links = haxe_ds_ObjectMap()

    def link(self,cell,bidirectional = None):
        if (bidirectional is None):
            bidirectional = True
        self._links.set(cell,True)
        if (bidirectional == True):
            cell.link(self,False)

    def unlink(self,cell,bidirectional = None):
        if (bidirectional is None):
            bidirectional = True
        self._links.remove(cell)
        if (bidirectional == True):
            cell.unlink(self,False)

    def links(self):
        return self._links.keys()

    def neighbors(self):
        r = []
        if (self.north is not None):
            x = self.north
            r.append(x)
        if (self.south is not None):
            x = self.south
            r.append(x)
        if (self.east is not None):
            x = self.east
            r.append(x)
        if (self.west is not None):
            x = self.west
            r.append(x)
        return r

    def isLinked(self,cell):
        return (cell in self._links.h)

    def distances(self):
        distances = Distances(self)
        frontier = [self]
        while (len(frontier) > 0):
            new_frontier = []
            _g = 0
            while (_g < len(frontier)):
                cell = (frontier[_g] if _g >= 0 and _g < len(frontier) else None)
                _g = (_g + 1)
                linked = cell.links()
                while linked.hasNext():
                    linked1 = linked.next()
                    if (distances.getDistance(linked1) is not None):
                        continue
                    distances.setDistance(linked1,(distances.getDistance(cell) + 1))
                    new_frontier.append(linked1)
            frontier = new_frontier
        return distances



class Class: pass


class Grid:
    _hx_class_name = "Grid"
    __slots__ = ("rows", "columns", "grid")
    _hx_fields = ["rows", "columns", "grid"]
    _hx_methods = ["at", "row", "randomCell", "size", "prepareGrid", "configureCells", "contentsOf", "backgroundColorFor", "string", "print", "rect", "png"]

    def __init__(self,rows,columns):
        self.grid = None
        self.rows = rows
        self.columns = columns
        self.grid = self.prepareGrid()
        self.configureCells()

    def at(self,row,column):
        if ((row < 0) or ((row >= self.rows))):
            return None
        if ((column < 0) or ((column >= self.columns))):
            return None
        return python_internal_ArrayImpl._get((self.grid[row] if row >= 0 and row < len(self.grid) else None), column)

    def row(self,row):
        if (row > self.rows):
            return None
        return (self.grid[row] if row >= 0 and row < len(self.grid) else None)

    def randomCell(self):
        x = self.rows
        row = (0 if ((x <= 0)) else int((python_lib_Random.random() * x)))
        x = len((self.grid[row] if row >= 0 and row < len(self.grid) else None))
        return self.at(row,(0 if ((x <= 0)) else int((python_lib_Random.random() * x))))

    def size(self):
        return (self.rows * self.columns)

    def prepareGrid(self):
        a = list()
        _hx_len = self.rows
        l = len(a)
        if (l < _hx_len):
            idx = (_hx_len - 1)
            v = None
            l1 = len(a)
            while (l1 < idx):
                a.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                a.append(v)
            else:
                a[idx] = v
        elif (l > _hx_len):
            pos = _hx_len
            len1 = (l - _hx_len)
            if (_hx_len < 0):
                pos = (len(a) + _hx_len)
            if (pos < 0):
                pos = 0
            a[pos:(pos + len1)]
            del a[pos:(pos + len1)]
        _g = 0
        _g1 = self.rows
        while (_g < _g1):
            row = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(a, row, list())
            _this = (a[row] if row >= 0 and row < len(a) else None)
            _hx_len = self.columns
            l = len(_this)
            if (l < _hx_len):
                idx = (_hx_len - 1)
                v = None
                l1 = len(_this)
                while (l1 < idx):
                    _this.append(None)
                    l1 = (l1 + 1)
                if (l1 == idx):
                    _this.append(v)
                else:
                    _this[idx] = v
            elif (l > _hx_len):
                pos = _hx_len
                len1 = (l - _hx_len)
                if (_hx_len < 0):
                    pos = (len(_this) + _hx_len)
                if (pos < 0):
                    pos = 0
                _this[pos:(pos + len1)]
                del _this[pos:(pos + len1)]
            _g2 = 0
            _g3 = self.columns
            while (_g2 < _g3):
                col = _g2
                _g2 = (_g2 + 1)
                python_internal_ArrayImpl._set((a[row] if row >= 0 and row < len(a) else None), col, Cell(row,col))
        return a

    def configureCells(self):
        cell = GridIterator(self)
        while cell.hasNext():
            cell1 = cell.next()
            row = cell1.row
            col = cell1.column
            cell1.north = self.at((row - 1),col)
            cell1.south = self.at((row + 1),col)
            cell1.east = self.at(row,(col + 1))
            cell1.west = self.at(row,(col - 1))

    def contentsOf(self,cell):
        return " "

    def backgroundColorFor(self,cell):
        return None

    def string(self):
        _g = []
        _g1 = 0
        _g2 = self.columns
        while (_g1 < _g2):
            _g1 = (_g1 + 1)
            _g.append("---+")
        output = (("+" + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "\n")
        row = GridRowIterator(self)
        while row.hasNext():
            row1 = row.next()
            top = "|"
            bottom = "+"
            _g = 0
            while (_g < len(row1)):
                cell = (row1[_g] if _g >= 0 and _g < len(row1) else None)
                _g = (_g + 1)
                if (cell is None):
                    cell = Cell(-1,-1)
                top = (("null" if top is None else top) + HxOverrides.stringOrNull((((" " + HxOverrides.stringOrNull(self.contentsOf(cell))) + " "))))
                top = (("null" if top is None else top) + HxOverrides.stringOrNull((" " if (cell.isLinked(cell.east)) else "|")))
                bottom = (("null" if bottom is None else bottom) + HxOverrides.stringOrNull(("   " if (cell.isLinked(cell.south)) else "---")))
                bottom = (("null" if bottom is None else bottom) + "+")
            output = (("null" if output is None else output) + HxOverrides.stringOrNull(((("null" if top is None else top) + "\n"))))
            output = (("null" if output is None else output) + HxOverrides.stringOrNull(((("null" if bottom is None else bottom) + "\n"))))
        return output

    def print(self):
        python_Lib.printString(Std.string(self.string()))

    def rect(self,x1,y1,x2,y2,color,lineThickness):
        i = (x2 - x1)
        i1 = (y2 - y1)
        return _hx_AnonObject({'x': (x1 - Math.floor((lineThickness / 2))), 'y': (y1 - Math.floor((lineThickness / 2))), 'width': (((-i if ((i < 0)) else i)) + Math.ceil((lineThickness / 2))), 'height': (((-i1 if ((i1 < 0)) else i1)) + Math.ceil((lineThickness / 2))), 'c': color, 'blend': None, 'fill': True})

    def png(self):
        file = sys_io_File.write("output.png")
        wallColor = 572662527
        PNG = bitmap_PNGBitmap((32 + ((32 * self.columns))),(32 + ((32 * self.rows))))
        PNG.fill(-1)
        _g = 0
        _g1 = ["backgrounds", "walls"]
        while (_g < len(_g1)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            mode = python_internal_ArrayImpl._get(_g1, _hx_local_1())
            cell = GridIterator(self)
            while cell.hasNext():
                cell1 = cell.next()
                x1 = ((cell1.column * 32) + 16)
                x2 = ((((cell1.column + 1)) * 32) + 16)
                y1 = ((cell1.row * 32) + 16)
                y2 = ((((cell1.row + 1)) * 32) + 16)
                if (mode == "backgrounds"):
                    color = self.backgroundColorFor(cell1)
                    if (color is not None):
                        PNG.draw.rectangle(self.rect(x1,y1,x2,y2,color,4))
                else:
                    if (cell1.north is None):
                        PNG.draw.rectangle(self.rect(x1,y1,x2,y1,wallColor,4))
                    if (cell1.west is None):
                        PNG.draw.rectangle(self.rect(x1,y1,x1,y2,wallColor,4))
                    if (not cell1.isLinked(cell1.east)):
                        PNG.draw.rectangle(self.rect(x2,y1,x2,y2,wallColor,4))
                    if (not cell1.isLinked(cell1.south)):
                        PNG.draw.rectangle(self.rect(x1,y2,x2,y2,wallColor,4))
        PNG.save(file)
        file.close()



class ColoredGrid(Grid):
    _hx_class_name = "ColoredGrid"
    __slots__ = ("distances", "max")
    _hx_fields = ["distances", "max"]
    _hx_methods = ["setDistances", "backgroundColorFor"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Grid


    def __init__(self,rows,columns):
        self.max = None
        self.distances = None
        super().__init__(rows,columns)

    def setDistances(self,distances):
        self.distances = distances
        self.max = distances.max().distance

    def backgroundColorFor(self,cell):
        distance = self.distances.getDistance(cell)
        if (distance is None):
            return None
        intensity = (((self.max - distance)) / self.max)
        dark = None
        try:
            dark = int((255 * intensity))
        except BaseException as _g:
            None
            dark = None
        dark1 = dark
        bright = None
        try:
            bright = int((127 * intensity))
        except BaseException as _g:
            None
            bright = None
        bright1 = (128 + bright)
        return (((((((0 if ((dark1 < 0)) else (255 if ((dark1 > 255)) else dark1))) << 24)) + ((((0 if ((bright1 < 0)) else (255 if ((bright1 > 255)) else bright1))) << 16))) + ((((0 if ((dark1 < 0)) else (255 if ((dark1 > 255)) else dark1))) << 8))) + 255)



class Distances:
    _hx_class_name = "Distances"
    __slots__ = ("root", "cells")
    _hx_fields = ["root", "cells"]
    _hx_methods = ["getDistance", "setDistance", "getCells", "pathTo", "max"]

    def __init__(self,root):
        self.root = root
        self.cells = haxe_ds_ObjectMap()
        self.cells.set(root,0)

    def getDistance(self,cell):
        return self.cells.h.get(cell,None)

    def setDistance(self,cell,dist):
        self.cells.set(cell,dist)

    def getCells(self):
        return self.cells.keys()

    def pathTo(self,goal):
        current = goal
        breadcrumbs = Distances(self.root)
        breadcrumbs.setDistance(goal,self.getDistance(goal))
        while (current != self.root):
            neighbor = current.links()
            while neighbor.hasNext():
                neighbor1 = neighbor.next()
                if (self.cells.h.get(neighbor1,None) < self.cells.h.get(current,None)):
                    breadcrumbs.setDistance(neighbor1,self.cells.h.get(neighbor1,None))
                    current = neighbor1
                    break
        return breadcrumbs

    def max(self):
        max_distance = 0
        max_cell = self.root
        this1 = self.cells
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g1_value = this1.get(key)
            if (_g1_value > max_distance):
                max_cell = key
                max_distance = _g1_value
        return _hx_AnonObject({'cell': max_cell, 'distance': max_distance})



class GridIterator:
    _hx_class_name = "GridIterator"
    __slots__ = ("grid", "row", "column")
    _hx_fields = ["grid", "row", "column"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,grid):
        self.grid = grid
        self.row = 0
        self.column = 0

    def hasNext(self):
        if (self.row < self.grid.rows):
            return (self.column < self.grid.columns)
        else:
            return False

    def next(self):
        thisRow = self.row
        thisCol = self.column
        self.column = (self.column + 1)
        if (self.column >= self.grid.columns):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.row
            _hx_local_0.row = (_hx_local_1 + 1)
            _hx_local_1
            self.column = 0
        return self.grid.at(thisRow,thisCol)



class GridRowIterator:
    _hx_class_name = "GridRowIterator"
    __slots__ = ("grid", "row")
    _hx_fields = ["grid", "row"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,grid):
        self.grid = grid
        self.row = 0

    def hasNext(self):
        return (self.row < self.grid.rows)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.row
                _hx_local_0.row = (_hx_local_1 + 1)
                return _hx_local_1
            return self.grid.row(_hx_local_2())
        return _hx_local_3()



class Main:
    _hx_class_name = "Main"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        g = ColoredGrid(12,12)
        BinaryTreeMaze.on(g)
        g.setDistances(g.at(0,0).distances())
        g.png()


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["isOfType", "string", "parseInt"]

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except BaseException as _g:
            None
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            while (_g < _hx_len):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except BaseException as _g:
                    return None
            return None


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["hex"]

    @staticmethod
    def hex(n,digits = None):
        s = ""
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len("0123456789ABCDEF"))))) else "0123456789ABCDEF"[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            while (_g < diff):
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s


class _Useful_Useful_Fields_:
    _hx_class_name = "_Useful.Useful_Fields_"
    __slots__ = ()
    _hx_statics = ["sampleArray", "intAbs"]

    @staticmethod
    def sampleArray(array):
        x = len(array)
        return python_internal_ArrayImpl._get(array, (0 if ((x <= 0)) else int((python_lib_Random.random() * x))))

    @staticmethod
    def intAbs(i):
        if (i < 0):
            return -i
        else:
            return i


class bitmap_RectangleArea:
    _hx_class_name = "bitmap.RectangleArea"
    __slots__ = ("width", "height")
    _hx_fields = ["width", "height"]


class bitmap_OffsetRectangleArea:
    _hx_class_name = "bitmap.OffsetRectangleArea"
    __slots__ = ("originalWidth", "originalHeight")
    _hx_fields = ["originalWidth", "originalHeight"]
    _hx_interfaces = [bitmap_RectangleArea]


class bitmap_Bitmap:
    _hx_class_name = "bitmap.Bitmap"
    __slots__ = ("data", "noRangeCheck", "draw", "color", "transform", "io", "bg")
    _hx_fields = ["data", "noRangeCheck", "draw", "color", "transform", "io", "bg"]
    _hx_methods = ["load", "save", "get", "set", "equals", "clone", "copyFrom", "fill", "copy", "compare", "bounds"]
    _hx_interfaces = [bitmap_OffsetRectangleArea]


class bitmap_AbstractBitmap:
    _hx_class_name = "bitmap.AbstractBitmap"
    __slots__ = ("noRangeCheck", "int32Mode", "data", "width", "height", "originalWidth", "originalHeight", "format", "draw", "io", "color", "transform", "bg")
    _hx_fields = ["noRangeCheck", "int32Mode", "data", "width", "height", "originalWidth", "originalHeight", "format", "draw", "io", "color", "transform", "bg"]
    _hx_methods = ["fill", "get", "toString", "byteIndex", "copy", "set", "load", "save", "clone", "equals", "copyFrom", "compare", "bounds", "setInt32", "setInt8", "getInt32", "getInt8"]
    _hx_interfaces = [bitmap_Bitmap]

    def __init__(self,w = None,h = None,f = None):
        if (w is None):
            w = 1
        if (h is None):
            h = 1
        if (f is None):
            f = bitmap_PixelFormat.RGBA
        self.transform = None
        self.color = None
        self.io = None
        self.draw = None
        self.format = None
        self.originalHeight = None
        self.originalWidth = None
        self.height = None
        self.width = None
        self.data = None
        self.bg = -1
        self.int32Mode = False
        self.noRangeCheck = True
        self.draw = bitmap_Draw(self)
        self.transform = bitmap_transformation_Transform(self)
        self.color = bitmap_transformation_Colors(self)
        self.io = bitmap_BitmapIO(self)
        if ((w > 0) and ((h > 0))):
            self.width = w
            self.height = h
            self.data = haxe_io_Bytes.alloc(((w * h) * 4))
            self.format = f
            self.fill()

    def fill(self,bg_ = None):
        if (bg_ is None):
            bg_ = self.bg
        _g = 0
        _g1 = self.width
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = self.height
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                self.set(x,y,bg_)

    def get(self,x,y,noError = None):
        i = (((self.width * y) + x) << 2)
        if ((i < 0) or ((i > ((self.data.length - 4))))):
            if ((not self.noRangeCheck) and (not noError)):
                raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + HxOverrides.stringOrNull(None)) + ", actual: ") + "get outOfBounds") + ")"))
            else:
                return self.bg
        if self.int32Mode:
            _this = self.data
            v = (((_this.b[i] | ((_this.b[(i + 1)] << 8))) | ((_this.b[(i + 2)] << 16))) | ((_this.b[(i + 3)] << 24)))
            c = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            return ((((((c >> 24) & 255)) + (((((c >> 16) & 255)) << 8))) + (((((c >> 8) & 255)) << 16))) + ((((c & 255)) << 24)))
        else:
            red = self.data.b[i]
            green = self.data.b[(i + 1)]
            blue = self.data.b[(i + 2)]
            alpha = self.data.b[(i + 3)]
            return (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))

    def toString(self):
        return (("Bitmap(" + HxOverrides.stringOrNull(bitmap_Util.printRectangle(self.bounds()))) + ")")

    def byteIndex(self,x,y):
        return (((self.width * y) + x) << 2)

    def copy(self,r):
        raise haxe_Exception.thrown("Abstract method call")

    def set(self,x,y,c,noError = None):
        i = (((self.width * y) + x) << 2)
        if ((i < 0) or ((i > ((self.data.length - 4))))):
            if ((not self.noRangeCheck) and ((noError != True))):
                raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + HxOverrides.stringOrNull(None)) + ", actual: ") + "set outOfBounds") + ")"))
            else:
                return True
        if self.int32Mode:
            _this = self.data
            v = ((((((c >> 24) & 255)) + (((c >> 8) & 65280))) + ((((c & 65280)) << 8))) + ((((c & 255)) << 24)))
            _this.b[i] = (v & 255)
            _this.b[(i + 1)] = ((v >> 8) & 255)
            _this.b[(i + 2)] = ((v >> 16) & 255)
            _this.b[(i + 3)] = (HxOverrides.rshift(v, 24) & 255)
        else:
            self.data.b[i] = ((HxOverrides.rshift(c, 24) & 255) & 255)
            self.data.b[(i + 1)] = ((HxOverrides.rshift(c, 16) & 255) & 255)
            self.data.b[(i + 2)] = ((HxOverrides.rshift(c, 8) & 255) & 255)
            self.data.b[(i + 3)] = ((c & 255) & 255)
        return False

    def load(self,input,f = None):
        raise haxe_Exception.thrown("Abstract method call")

    def save(self,output):
        raise haxe_Exception.thrown("Abstract method call")

    def clone(self,fill_ = None):
        if (fill_ is None):
            fill_ = False
        bitmap = bitmap_PNGBitmap()
        bitmap.width = self.width
        bitmap.height = self.height
        bitmap.format = self.format
        bitmap.noRangeCheck = self.noRangeCheck
        if (not fill_):
            bitmap.data = self.data.sub(0,self.data.length)
        else:
            bitmap.data = haxe_io_Bytes.alloc(self.data.length)
            bitmap.fill()
        return bitmap

    def equals(self,b,region = None):
        return bitmap_BitmapUtil.bitmapEquals(self,b,region)

    def copyFrom(self,b,bCoords,regionThis):
        _g = 0
        _g1 = regionThis.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = regionThis.width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                self.set((regionThis.x + x),(regionThis.y + y),b.get((bCoords.x + x),(bCoords.y + y)))

    def compare(self,b,regionB = None,thisRegion = None):
        return bitmap_BitmapUtil.compare(self,b,regionB,thisRegion)

    def bounds(self):
        return _hx_AnonObject({'x': 0, 'y': 0, 'width': self.width, 'height': self.height})

    def setInt32(self,i,c):
        _this = self.data
        v = ((((((c >> 24) & 255)) + (((c >> 8) & 65280))) + ((((c & 65280)) << 8))) + ((((c & 255)) << 24)))
        _this.b[i] = (v & 255)
        _this.b[(i + 1)] = ((v >> 8) & 255)
        _this.b[(i + 2)] = ((v >> 16) & 255)
        _this.b[(i + 3)] = (HxOverrides.rshift(v, 24) & 255)

    def setInt8(self,i,c):
        self.data.b[i] = ((HxOverrides.rshift(c, 24) & 255) & 255)
        self.data.b[(i + 1)] = ((HxOverrides.rshift(c, 16) & 255) & 255)
        self.data.b[(i + 2)] = ((HxOverrides.rshift(c, 8) & 255) & 255)
        self.data.b[(i + 3)] = ((c & 255) & 255)

    def getInt32(self,i):
        _this = self.data
        v = (((_this.b[i] | ((_this.b[(i + 1)] << 8))) | ((_this.b[(i + 2)] << 16))) | ((_this.b[(i + 3)] << 24)))
        c = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        return ((((((c >> 24) & 255)) + (((((c >> 16) & 255)) << 8))) + (((((c >> 8) & 255)) << 16))) + ((((c & 255)) << 24)))

    def getInt8(self,i):
        red = self.data.b[i]
        green = self.data.b[(i + 1)]
        blue = self.data.b[(i + 2)]
        alpha = self.data.b[(i + 3)]
        return (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))



class bitmap_BitmapIO:
    _hx_class_name = "bitmap.BitmapIO"
    __slots__ = ("bitmap",)
    _hx_fields = ["bitmap"]
    _hx_methods = ["toDataUrl", "toBase64", "fromBase64", "fromDataUrl"]

    def __init__(self,b):
        self.bitmap = b

    def toDataUrl(self,mime = None,name = None):
        if (mime is None):
            mime = "image/png"
        return bitmap_BitmapUtil.toDataUrl(self.bitmap,mime,name)

    def toBase64(self):
        return bitmap_BitmapUtil.toBase64(self.bitmap)

    def fromBase64(self,base64):
        return bitmap_BitmapUtil.fromBase64(base64,self.bitmap)

    def fromDataUrl(self,dataurl):
        return bitmap_BitmapUtil.fromDataUrl(dataurl,self.bitmap)



class bitmap_BitmapUtil:
    _hx_class_name = "bitmap.BitmapUtil"
    __slots__ = ()
    _hx_statics = ["bitmapEquals", "compare", "blend", "toDataUrl", "toBase64", "fromBase64", "fromDataUrl"]

    @staticmethod
    def bitmapEquals(a,b,region = None):
        if ((a.width != b.width) or ((a.height != b.height))):
            return False
        if (region is None):
            first = a.width
            second = b.width
            first1 = a.height
            second1 = b.height
            region = _hx_AnonObject({'x': 0, 'y': 0, 'width': (first if ((first < second)) else second), 'height': (first1 if ((first1 < second1)) else second1)})
        return (a.data.compare(b.data) == 0)

    @staticmethod
    def compare(a,b,regionA = None,regionB = None):
        if (((regionA is None) and ((regionB is None))) and (((a.width != b.width) or ((b.height != a.height))))):
            raise haxe_Exception.thrown("No regions given and bitmaps with different sizes")
        if (regionA is None):
            regionA = (a.bounds() if ((regionB is None)) else regionB)
        if (regionB is None):
            regionB = (b.bounds() if ((regionA is None)) else regionA)
        if ((regionA.width != regionB.width) or ((regionA.height != regionB.height))):
            raise haxe_Exception.thrown("Regions given or inferred have different sizes")
        va = 0
        vb = 0
        startA = a.byteIndex(regionA.x,regionA.y)
        endA = a.byteIndex((regionA.x + regionA.width),(regionA.y + regionA.height))
        startB = a.byteIndex(regionB.x,regionB.y)
        endB = a.byteIndex((regionB.x + regionB.width),(regionB.y + regionB.height))
        actual = (endA - startA)
        expected = (endB - startB)
        if (actual != expected):
            raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + Std.string(expected)) + ", actual: ") + Std.string(actual)) + ")"))
        if (not (((endA > startA) and ((endB > startB))))):
            raise haxe_Exception.thrown("FAIL: endA > startA && endB > startB")
        if (not (((startA >= 0) and ((startB >= 0))))):
            raise haxe_Exception.thrown("FAIL: startA >= 0 && startB >= 0")
        _g = 0
        _g1 = (endA - startA)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            v = a.data.b[(startA + i)]
            va = (va + (0 if (python_lib_Math.isnan(v)) else v))
            v = b.data.b[(startB + i)]
            vb = (vb + (0 if (python_lib_Math.isnan(v)) else v))
        return ((bitmap_Util.dist(va,vb) / ((((endA - startA)) * 255))) * ((-1 if ((va > vb)) else 1)))

    @staticmethod
    def blend(b1,b2,b3,blend = None):
        first = b1.width
        second = b2.width
        w = (first if ((first < second)) else second)
        first = b1.height
        second = b2.height
        _g = 0
        _g1 = (first if ((first < second)) else second)
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = w
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                c1 = b1.get(x,y)
                c2 = b2.get(x,y)
                blend1 = blend
                blend1 = (_hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5}) if ((blend is None)) else blend)
                Reflect.setField(blend1,"factor",(0.5 if ((Reflect.field(blend1,"factor") is None)) else Reflect.field(blend1,"factor")))
                tmp = None
                if (blend1.type == bitmap_Blend.alpha):
                    tmp = c2
                elif (blend1.type == bitmap_Blend.mean):
                    _hx_int = (HxOverrides.rshift(c1, 24) & 255)
                    int1 = (HxOverrides.rshift(c2, 24) & 255)
                    x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                    red = None
                    try:
                        red = int(x1)
                    except BaseException as _g4:
                        None
                        red = None
                    int2 = (HxOverrides.rshift(c1, 16) & 255)
                    int3 = (HxOverrides.rshift(c2, 16) & 255)
                    x2 = (((((4294967296.0 + int2) if ((int2 < 0)) else (int2 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int3) if ((int3 < 0)) else (int3 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                    green = None
                    try:
                        green = int(x2)
                    except BaseException as _g5:
                        None
                        green = None
                    int4 = (HxOverrides.rshift(c1, 8) & 255)
                    int5 = (HxOverrides.rshift(c2, 8) & 255)
                    x3 = (((((4294967296.0 + int4) if ((int4 < 0)) else (int4 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int5) if ((int5 < 0)) else (int5 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                    blue = None
                    try:
                        blue = int(x3)
                    except BaseException as _g6:
                        None
                        blue = None
                    int6 = (c1 & 255)
                    int7 = (c2 & 255)
                    x4 = (((((4294967296.0 + int6) if ((int6 < 0)) else (int6 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int7) if ((int7 < 0)) else (int7 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                    alpha = None
                    try:
                        alpha = int(x4)
                    except BaseException as _g7:
                        None
                        alpha = None
                    tmp = (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
                else:
                    tmp = c2
                b3.set(x,y,tmp)
        return b3

    @staticmethod
    def toDataUrl(bitmap,mime = None,name = None):
        if (mime is None):
            mime = "image/png"
        b64 = bitmap_BitmapUtil.toBase64(bitmap)
        return ((((("data:" + ("null" if mime is None else mime)) + ";") + HxOverrides.stringOrNull((("" if ((name is None)) else (("null" if name is None else name) + ";"))))) + "base64,") + ("null" if b64 is None else b64))

    @staticmethod
    def toBase64(bitmap):
        ii = haxe_io_BytesOutput()
        bitmap.save(ii)
        return haxe_crypto_Base64.encode(ii.getBytes())

    @staticmethod
    def fromBase64(base64,bitmap = None):
        if (bitmap is None):
            bitmap = bitmap_PNGBitmap()
        bitmap.load(haxe_io_BytesInput(haxe_crypto_Base64.decode(base64)))
        return bitmap

    @staticmethod
    def fromDataUrl(dataurl,bitmap = None):
        return bitmap_BitmapUtil.fromBase64(bitmap_Util.urlToBase64(dataurl),bitmap)


class bitmap__Color_Color_Impl_:
    _hx_class_name = "bitmap._Color.Color_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "create", "fromString", "fromInt", "toString", "get_r", "get_g", "get_b", "get_a", "set_r", "set_g", "set_b", "set_a"]
    r = None
    g = None
    b = None
    a = None

    @staticmethod
    def _new(rgba):
        return rgba

    @staticmethod
    def create(red,green,blue,alpha):
        return (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))

    @staticmethod
    def fromString(s):
        if (s.find("#") == 0):
            return Std.parseInt(("0x" + HxOverrides.stringOrNull(HxString.substring(s,1,len(s)))))
        elif (s.find("0x") == 0):
            return Std.parseInt(s)
        return 0

    @staticmethod
    def fromInt(rgba):
        return rgba

    @staticmethod
    def toString(this1):
        return ("0x" + HxOverrides.stringOrNull(StringTools.hex(this1,8)))

    @staticmethod
    def get_r(this1):
        return (HxOverrides.rshift(this1, 24) & 255)

    @staticmethod
    def get_g(this1):
        return (HxOverrides.rshift(this1, 16) & 255)

    @staticmethod
    def get_b(this1):
        return (HxOverrides.rshift(this1, 8) & 255)

    @staticmethod
    def get_a(this1):
        return (this1 & 255)

    @staticmethod
    def set_r(this1,value):
        this1 = ((((value << 24) | (((HxOverrides.rshift(this1, 16) & 255)) << 16)) | (((HxOverrides.rshift(this1, 8) & 255)) << 8)) | (this1 & 255))
        return value

    @staticmethod
    def set_g(this1,value):
        this1 = ((((((HxOverrides.rshift(this1, 24) & 255)) << 24) | (value << 16)) | (((HxOverrides.rshift(this1, 8) & 255)) << 8)) | (this1 & 255))
        return value

    @staticmethod
    def set_b(this1,value):
        this1 = ((((((HxOverrides.rshift(this1, 24) & 255)) << 24) | (((HxOverrides.rshift(this1, 16) & 255)) << 16)) | (value << 8)) | (this1 & 255))
        return value

    @staticmethod
    def set_a(this1,value):
        this1 = ((((((HxOverrides.rshift(this1, 24) & 255)) << 24) | (((HxOverrides.rshift(this1, 16) & 255)) << 16)) | (((HxOverrides.rshift(this1, 8) & 255)) << 8)) | value)
        return value


class bitmap_ColorUtil:
    _hx_class_name = "bitmap.ColorUtil"
    __slots__ = ()
    _hx_methods = ["mix"]
    _hx_statics = ["colorEquals", "average", "random", "randomGray", "blendColors", "filter"]

    def mix(self,c1,c2,strength):
        output = 0
        _hx_int = (HxOverrides.rshift(c1, 24) & 255)
        int1 = (HxOverrides.rshift(c2, 24) & 255)
        output = ((((Math.floor((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * ((1 - strength))) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * strength)))) << 24) | (((HxOverrides.rshift(output, 16) & 255)) << 16)) | (((HxOverrides.rshift(output, 8) & 255)) << 8)) | (output & 255))
        _hx_int = (HxOverrides.rshift(c1, 16) & 255)
        int1 = (HxOverrides.rshift(c2, 16) & 255)
        output = ((((((HxOverrides.rshift(output, 24) & 255)) << 24) | (Math.floor((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * ((1 - strength))) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * strength)))) << 16)) | (((HxOverrides.rshift(output, 8) & 255)) << 8)) | (output & 255))
        _hx_int = (HxOverrides.rshift(c1, 8) & 255)
        int1 = (HxOverrides.rshift(c2, 8) & 255)
        output = ((((((HxOverrides.rshift(output, 24) & 255)) << 24) | (((HxOverrides.rshift(output, 16) & 255)) << 16)) | (Math.floor((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * ((1 - strength))) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * strength)))) << 8)) | (output & 255))
        _hx_int = (c1 & 255)
        int1 = (c2 & 255)
        output = ((((((HxOverrides.rshift(output, 24) & 255)) << 24) | (((HxOverrides.rshift(output, 16) & 255)) << 16)) | (((HxOverrides.rshift(output, 8) & 255)) << 8)) | Math.floor((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * ((1 - strength))) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * strength)))))
        return output

    @staticmethod
    def colorEquals(a,b):
        if (((((HxOverrides.rshift(a, 24) & 255)) == ((HxOverrides.rshift(b, 24) & 255))) and ((((HxOverrides.rshift(a, 16) & 255)) == ((HxOverrides.rshift(b, 16) & 255))))) and ((((HxOverrides.rshift(a, 8) & 255)) == ((HxOverrides.rshift(b, 8) & 255))))):
            return (((a & 255)) == ((b & 255)))
        else:
            return False

    @staticmethod
    def average(image,region = None,alpha = None):
        if (image is None):
            raise haxe_Exception.thrown("FAIL: image != null")
        totalRed = 0
        totalGreen = 0
        totalBlue = 0
        totalAlpha = 0
        if (region is None):
            region = _hx_AnonObject({'x': 0, 'y': 0, 'width': image.width, 'height': image.height})
        _g = region.x
        _g1 = (region.x + region.width)
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = region.y
            _g3 = (region.y + region.height)
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                pixel = image.get(x,y)
                totalRed = (totalRed + ((HxOverrides.rshift(pixel, 24) & 255)))
                totalGreen = (totalGreen + ((HxOverrides.rshift(pixel, 16) & 255)))
                totalBlue = (totalBlue + ((HxOverrides.rshift(pixel, 8) & 255)))
                totalAlpha = (totalAlpha + ((pixel & 255)))
        size = (region.width * region.height)
        x = Math.floor(((totalRed / size) + 0.5))
        red = None
        try:
            red = int(x)
        except BaseException as _g:
            None
            red = None
        x = Math.floor(((totalGreen / size) + 0.5))
        green = None
        try:
            green = int(x)
        except BaseException as _g:
            None
            green = None
        x = Math.floor(((totalBlue / size) + 0.5))
        blue = None
        try:
            blue = int(x)
        except BaseException as _g:
            None
            blue = None
        alpha1 = None
        if (alpha is None):
            x = Math.floor(((totalAlpha / size) + 0.5))
            try:
                alpha1 = int(x)
            except BaseException as _g:
                None
                alpha1 = None
        else:
            alpha1 = alpha
        return (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha1 < 0)) else (255 if ((alpha1 > 255)) else alpha1))))

    @staticmethod
    def random(alpha = None):
        red = Math.floor(((255 * python_lib_Random.random()) + 0.5))
        green = Math.floor(((255 * python_lib_Random.random()) + 0.5))
        blue = Math.floor(((255 * python_lib_Random.random()) + 0.5))
        alpha1 = (Math.floor(((255 * python_lib_Random.random()) + 0.5)) if ((alpha is None)) else alpha)
        return (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha1 < 0)) else (255 if ((alpha1 > 255)) else alpha1))))

    @staticmethod
    def randomGray(alpha = None):
        g = Math.floor(((255 * python_lib_Random.random()) + 0.5))
        alpha1 = (Math.floor(((255 * python_lib_Random.random()) + 0.5)) if ((alpha is None)) else alpha)
        return (((((((0 if ((g < 0)) else (255 if ((g > 255)) else g))) << 24)) + ((((0 if ((g < 0)) else (255 if ((g > 255)) else g))) << 16))) + ((((0 if ((g < 0)) else (255 if ((g > 255)) else g))) << 8))) + ((0 if ((alpha1 < 0)) else (255 if ((alpha1 > 255)) else alpha1))))

    @staticmethod
    def blendColors(c1,c2,blend = None):
        if (blend is None):
            blend = _hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5})
        Reflect.setField(blend,"factor",(0.5 if ((Reflect.field(blend,"factor") is None)) else Reflect.field(blend,"factor")))
        if (blend.type == bitmap_Blend.alpha):
            return c2
        elif (blend.type == bitmap_Blend.mean):
            _hx_int = (HxOverrides.rshift(c1, 24) & 255)
            int1 = (HxOverrides.rshift(c2, 24) & 255)
            x = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
            red = None
            try:
                red = int(x)
            except BaseException as _g:
                None
                red = None
            _hx_int = (HxOverrides.rshift(c1, 16) & 255)
            int1 = (HxOverrides.rshift(c2, 16) & 255)
            x = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
            green = None
            try:
                green = int(x)
            except BaseException as _g:
                None
                green = None
            _hx_int = (HxOverrides.rshift(c1, 8) & 255)
            int1 = (HxOverrides.rshift(c2, 8) & 255)
            x = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
            blue = None
            try:
                blue = int(x)
            except BaseException as _g:
                None
                blue = None
            _hx_int = (c1 & 255)
            int1 = (c2 & 255)
            x = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
            alpha = None
            try:
                alpha = int(x)
            except BaseException as _g:
                None
                alpha = None
            return (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
        else:
            return c2

    @staticmethod
    def filter(c,o):
        c2 = None
        if (Reflect.field(o,"fn") is not None):
            c2 = Reflect.field(o,"fn")(c,o)
        else:
            Reflect.setField(o,"red",(_hx_AnonObject({'a': 1.0, 'c': 0.0}) if ((Reflect.field(o,"red") is None)) else Reflect.field(o,"red")))
            Reflect.setField(o,"green",(_hx_AnonObject({'a': 1.0, 'c': 0.0}) if ((Reflect.field(o,"green") is None)) else Reflect.field(o,"green")))
            Reflect.setField(o,"blue",(_hx_AnonObject({'a': 1.0, 'c': 0.0}) if ((Reflect.field(o,"blue") is None)) else Reflect.field(o,"blue")))
            Reflect.setField(o,"alpha",(_hx_AnonObject({'a': 1.0, 'c': 0.0}) if ((Reflect.field(o,"alpha") is None)) else Reflect.field(o,"alpha")))
            _hx_int = (HxOverrides.rshift(c, 24) & 255)
            red = Math.floor(((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(o,"red").a) + Reflect.field(o,"red").c) + 0.5))
            _hx_int = (HxOverrides.rshift(c, 16) & 255)
            green = Math.floor(((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(o,"green").a) + Reflect.field(o,"green").c) + 0.5))
            _hx_int = (HxOverrides.rshift(c, 8) & 255)
            blue = Math.floor(((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(o,"blue").a) + Reflect.field(o,"blue").c) + 0.5))
            _hx_int = (c & 255)
            alpha = Math.floor(((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(o,"alpha").a) + Reflect.field(o,"alpha").c) + 0.5))
            c2 = (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
        if (Reflect.field(o,"blend") is None):
            return c2
        else:
            blend = Reflect.field(o,"blend")
            if (blend is None):
                blend = _hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5})
            Reflect.setField(blend,"factor",(0.5 if ((Reflect.field(blend,"factor") is None)) else Reflect.field(blend,"factor")))
            if (blend.type == bitmap_Blend.alpha):
                return c2
            elif (blend.type == bitmap_Blend.mean):
                _hx_int = (HxOverrides.rshift(c, 24) & 255)
                int1 = (HxOverrides.rshift(c2, 24) & 255)
                x = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
                red = None
                try:
                    red = int(x)
                except BaseException as _g:
                    None
                    red = None
                _hx_int = (HxOverrides.rshift(c, 16) & 255)
                int1 = (HxOverrides.rshift(c2, 16) & 255)
                x = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
                green = None
                try:
                    green = int(x)
                except BaseException as _g:
                    None
                    green = None
                _hx_int = (HxOverrides.rshift(c, 8) & 255)
                int1 = (HxOverrides.rshift(c2, 8) & 255)
                x = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
                blue = None
                try:
                    blue = int(x)
                except BaseException as _g:
                    None
                    blue = None
                _hx_int = (c & 255)
                int1 = (c2 & 255)
                x = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
                alpha = None
                try:
                    alpha = int(x)
                except BaseException as _g:
                    None
                    alpha = None
                return (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
            else:
                return c2



class bitmap_Draw:
    _hx_class_name = "bitmap.Draw"
    __slots__ = ("bitmap",)
    _hx_fields = ["bitmap"]
    _hx_methods = ["line", "rectangle", "rectangle2", "triangle", "set"]

    def __init__(self,b):
        self.bitmap = b

    def line(self,x1,y1,x2,y2,c,blend = None,returnPoints = None):
        if (returnPoints is None):
            returnPoints = False
        dx = (x2 - x1)
        dy = (y2 - y1)
        dxabs = (-dx if ((dx < 0)) else dx)
        dyabs = (-dy if ((dy < 0)) else dy)
        sdx = (-1 if ((dx < 0)) else (1 if ((dx > 0)) else 0))
        sdy = (-1 if ((dy < 0)) else (1 if ((dy > 0)) else 0))
        x = (dyabs >> 1)
        y = (dxabs >> 1)
        px = x1
        py = y1
        points = []
        if (dxabs >= dyabs):
            _g = 0
            _g1 = dxabs
            while (_g < _g1):
                _g = (_g + 1)
                y = (y + dyabs)
                if (y >= dxabs):
                    y = (y - dxabs)
                    py = (py + sdy)
                px = (px + sdx)
                tmp = self.bitmap
                tmp1 = None
                if ((blend is None) or ((blend.type == bitmap_Blend.none))):
                    tmp1 = c
                else:
                    c1 = self.bitmap.get(px,py)
                    blend1 = blend
                    blend1 = (_hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5}) if ((blend is None)) else blend)
                    Reflect.setField(blend1,"factor",(0.5 if ((Reflect.field(blend1,"factor") is None)) else Reflect.field(blend1,"factor")))
                    if (blend1.type == bitmap_Blend.alpha):
                        tmp1 = c
                    elif (blend1.type == bitmap_Blend.mean):
                        _hx_int = (HxOverrides.rshift(c1, 24) & 255)
                        int1 = (HxOverrides.rshift(c, 24) & 255)
                        x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        red = None
                        try:
                            red = int(x1)
                        except BaseException as _g2:
                            None
                            red = None
                        int2 = (HxOverrides.rshift(c1, 16) & 255)
                        int3 = (HxOverrides.rshift(c, 16) & 255)
                        x2 = (((((4294967296.0 + int2) if ((int2 < 0)) else (int2 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int3) if ((int3 < 0)) else (int3 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        green = None
                        try:
                            green = int(x2)
                        except BaseException as _g3:
                            None
                            green = None
                        int4 = (HxOverrides.rshift(c1, 8) & 255)
                        int5 = (HxOverrides.rshift(c, 8) & 255)
                        x3 = (((((4294967296.0 + int4) if ((int4 < 0)) else (int4 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int5) if ((int5 < 0)) else (int5 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        blue = None
                        try:
                            blue = int(x3)
                        except BaseException as _g4:
                            None
                            blue = None
                        int6 = (c1 & 255)
                        int7 = (c & 255)
                        x4 = (((((4294967296.0 + int6) if ((int6 < 0)) else (int6 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int7) if ((int7 < 0)) else (int7 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        alpha = None
                        try:
                            alpha = int(x4)
                        except BaseException as _g5:
                            None
                            alpha = None
                        tmp1 = (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
                    else:
                        tmp1 = c
                tmp.set(px,py,tmp1)
                points.append(_hx_AnonObject({'x': px, 'y': py}))
        else:
            _g = 0
            _g1 = dyabs
            while (_g < _g1):
                _g = (_g + 1)
                x = (x + dxabs)
                if (x >= dyabs):
                    x = (x - dyabs)
                    px = (px + sdx)
                py = (py + sdy)
                tmp = self.bitmap
                tmp1 = None
                if ((blend is None) or ((blend.type == bitmap_Blend.none))):
                    tmp1 = c
                else:
                    c1 = self.bitmap.get(px,py)
                    blend1 = blend
                    blend1 = (_hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5}) if ((blend is None)) else blend)
                    Reflect.setField(blend1,"factor",(0.5 if ((Reflect.field(blend1,"factor") is None)) else Reflect.field(blend1,"factor")))
                    if (blend1.type == bitmap_Blend.alpha):
                        tmp1 = c
                    elif (blend1.type == bitmap_Blend.mean):
                        _hx_int = (HxOverrides.rshift(c1, 24) & 255)
                        int1 = (HxOverrides.rshift(c, 24) & 255)
                        x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        red = None
                        try:
                            red = int(x1)
                        except BaseException as _g2:
                            None
                            red = None
                        int2 = (HxOverrides.rshift(c1, 16) & 255)
                        int3 = (HxOverrides.rshift(c, 16) & 255)
                        x2 = (((((4294967296.0 + int2) if ((int2 < 0)) else (int2 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int3) if ((int3 < 0)) else (int3 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        green = None
                        try:
                            green = int(x2)
                        except BaseException as _g3:
                            None
                            green = None
                        int4 = (HxOverrides.rshift(c1, 8) & 255)
                        int5 = (HxOverrides.rshift(c, 8) & 255)
                        x3 = (((((4294967296.0 + int4) if ((int4 < 0)) else (int4 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int5) if ((int5 < 0)) else (int5 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        blue = None
                        try:
                            blue = int(x3)
                        except BaseException as _g4:
                            None
                            blue = None
                        int6 = (c1 & 255)
                        int7 = (c & 255)
                        x4 = (((((4294967296.0 + int6) if ((int6 < 0)) else (int6 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int7) if ((int7 < 0)) else (int7 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        alpha = None
                        try:
                            alpha = int(x4)
                        except BaseException as _g5:
                            None
                            alpha = None
                        tmp1 = (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
                    else:
                        tmp1 = c
                tmp.set(px,py,tmp1)
                points.append(_hx_AnonObject({'x': px, 'y': py}))
        return points

    def rectangle(self,r):
        if Reflect.field(r,"fill"):
            _g = 0
            _g1 = r.height
            while (_g < _g1):
                y2 = _g
                _g = (_g + 1)
                _g2 = 0
                _g3 = r.width
                while (_g2 < _g3):
                    x2 = _g2
                    _g2 = (_g2 + 1)
                    x = (x2 + r.x)
                    y = (y2 + r.y)
                    c = r.c
                    blend = Reflect.field(r,"blend")
                    tmp = self.bitmap
                    tmp1 = None
                    if ((blend is None) or ((blend.type == bitmap_Blend.none))):
                        tmp1 = c
                    else:
                        c1 = self.bitmap.get(x,y)
                        blend1 = blend
                        blend1 = (_hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5}) if ((blend is None)) else blend)
                        Reflect.setField(blend1,"factor",(0.5 if ((Reflect.field(blend1,"factor") is None)) else Reflect.field(blend1,"factor")))
                        if (blend1.type == bitmap_Blend.alpha):
                            tmp1 = c
                        elif (blend1.type == bitmap_Blend.mean):
                            _hx_int = (HxOverrides.rshift(c1, 24) & 255)
                            int1 = (HxOverrides.rshift(c, 24) & 255)
                            x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                            red = None
                            try:
                                red = int(x1)
                            except BaseException as _g4:
                                None
                                red = None
                            int2 = (HxOverrides.rshift(c1, 16) & 255)
                            int3 = (HxOverrides.rshift(c, 16) & 255)
                            x3 = (((((4294967296.0 + int2) if ((int2 < 0)) else (int2 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int3) if ((int3 < 0)) else (int3 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                            green = None
                            try:
                                green = int(x3)
                            except BaseException as _g5:
                                None
                                green = None
                            int4 = (HxOverrides.rshift(c1, 8) & 255)
                            int5 = (HxOverrides.rshift(c, 8) & 255)
                            x4 = (((((4294967296.0 + int4) if ((int4 < 0)) else (int4 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int5) if ((int5 < 0)) else (int5 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                            blue = None
                            try:
                                blue = int(x4)
                            except BaseException as _g6:
                                None
                                blue = None
                            int6 = (c1 & 255)
                            int7 = (c & 255)
                            x5 = (((((4294967296.0 + int6) if ((int6 < 0)) else (int6 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int7) if ((int7 < 0)) else (int7 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                            alpha = None
                            try:
                                alpha = int(x5)
                            except BaseException as _g7:
                                None
                                alpha = None
                            tmp1 = (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
                        else:
                            tmp1 = c
                    tmp.set(x,y,tmp1)
        else:
            self.line(r.x,r.y,(r.x + r.width),r.y,r.c,Reflect.field(r,"blend"))
            self.line((r.x + r.width),r.y,(r.x + r.width),(r.y + r.height),r.c,Reflect.field(r,"blend"))
            self.line((r.x + r.width),(r.y + r.height),r.x,(r.y + r.height),r.c,Reflect.field(r,"blend"))
            self.line(r.x,(r.y + r.height),r.x,r.y,r.c,Reflect.field(r,"blend"))

    def rectangle2(self,x,y,width,height,c,fill = None,blend = None):
        self.rectangle(_hx_AnonObject({'x': x, 'y': y, 'width': width, 'height': height, 'c': c, 'fill': fill, 'blend': blend}))

    def triangle(self,x1,y1,x2,y2,x3,y3,c,fill = None,blend = None):
        if (fill is None):
            fill = False
        points = self.line(x1,y1,x2,y2,c,blend,fill)
        points = (points + self.line(x2,y2,x3,y3,c,blend,fill))
        points = (points + self.line(x3,y3,x1,y1,c,blend,fill))
        if (not fill):
            return
        second = (y2 if ((y2 > y3)) else y3)
        second1 = (y2 if ((y2 < y3)) else y3)
        _g = (y1 if ((y1 < second1)) else second1)
        _g1 = (((y1 if ((y1 > second)) else second)) + 1)
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            y1 = [y]
            def _hx_local_1(y):
                def _hx_local_0(p):
                    return (Math.floor((p.y + 0.5)) == (y[0] if 0 < len(y) else None))
                return _hx_local_0
            found = list(filter(_hx_local_1(y1),points))
            if (len(found) > 1):
                if (len(found) > 2):
                    def _hx_local_3():
                        def _hx_local_2(p):
                            return p.x
                        return _hx_local_2
                    a = list(map(_hx_local_3(),found))
                    e = None
                    if ((a is None) or ((len(a) == 0))):
                        e = _hx_AnonObject({'min': 0, 'max': 0})
                    else:
                        _hx_min = (a[0] if 0 < len(a) else None)
                        _hx_max = (a[0] if 0 < len(a) else None)
                        _g2 = 0
                        while (_g2 < len(a)):
                            value = (a[_g2] if _g2 >= 0 and _g2 < len(a) else None)
                            _g2 = (_g2 + 1)
                            if (_hx_min > value):
                                _hx_min = value
                            if (_hx_max < value):
                                _hx_max = value
                        e = _hx_AnonObject({'min': _hx_min, 'max': _hx_max})
                    self.line(e.min,(y1[0] if 0 < len(y1) else None),e.max,(y1[0] if 0 < len(y1) else None),c,blend)
                else:
                    self.line((found[0] if 0 < len(found) else None).x,(y1[0] if 0 < len(y1) else None),(found[1] if 1 < len(found) else None).x,(y1[0] if 0 < len(y1) else None),c,blend)
            elif (len(found) == 1):
                x = (found[0] if 0 < len(found) else None).x
                y2 = (found[0] if 0 < len(found) else None).y
                tmp = self.bitmap
                tmp1 = None
                if ((blend is None) or ((blend.type == bitmap_Blend.none))):
                    tmp1 = c
                else:
                    c1 = self.bitmap.get(x,y2)
                    blend1 = blend
                    blend1 = (_hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5}) if ((blend is None)) else blend)
                    Reflect.setField(blend1,"factor",(0.5 if ((Reflect.field(blend1,"factor") is None)) else Reflect.field(blend1,"factor")))
                    if (blend1.type == bitmap_Blend.alpha):
                        tmp1 = c
                    elif (blend1.type == bitmap_Blend.mean):
                        _hx_int = (HxOverrides.rshift(c1, 24) & 255)
                        int1 = (HxOverrides.rshift(c, 24) & 255)
                        x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        red = None
                        try:
                            red = int(x1)
                        except BaseException as _g3:
                            None
                            red = None
                        int2 = (HxOverrides.rshift(c1, 16) & 255)
                        int3 = (HxOverrides.rshift(c, 16) & 255)
                        x2 = (((((4294967296.0 + int2) if ((int2 < 0)) else (int2 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int3) if ((int3 < 0)) else (int3 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        green = None
                        try:
                            green = int(x2)
                        except BaseException as _g4:
                            None
                            green = None
                        int4 = (HxOverrides.rshift(c1, 8) & 255)
                        int5 = (HxOverrides.rshift(c, 8) & 255)
                        x3 = (((((4294967296.0 + int4) if ((int4 < 0)) else (int4 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int5) if ((int5 < 0)) else (int5 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        blue = None
                        try:
                            blue = int(x3)
                        except BaseException as _g5:
                            None
                            blue = None
                        int6 = (c1 & 255)
                        int7 = (c & 255)
                        x4 = (((((4294967296.0 + int6) if ((int6 < 0)) else (int6 + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int7) if ((int7 < 0)) else (int7 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                        alpha = None
                        try:
                            alpha = int(x4)
                        except BaseException as _g6:
                            None
                            alpha = None
                        tmp1 = (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
                    else:
                        tmp1 = c
                tmp.set(x,y2,tmp1)
            else:
                print(str(len(found)))

    def set(self,x,y,c,blend = None):
        tmp = self.bitmap
        tmp1 = None
        if ((blend is None) or ((blend.type == bitmap_Blend.none))):
            tmp1 = c
        else:
            c1 = self.bitmap.get(x,y)
            blend1 = blend
            blend1 = (_hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5}) if ((blend is None)) else blend)
            Reflect.setField(blend1,"factor",(0.5 if ((Reflect.field(blend1,"factor") is None)) else Reflect.field(blend1,"factor")))
            if (blend1.type == bitmap_Blend.alpha):
                tmp1 = c
            elif (blend1.type == bitmap_Blend.mean):
                _hx_int = (HxOverrides.rshift(c1, 24) & 255)
                int1 = (HxOverrides.rshift(c, 24) & 255)
                x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                red = None
                try:
                    red = int(x1)
                except BaseException as _g:
                    None
                    red = None
                _hx_int = (HxOverrides.rshift(c1, 16) & 255)
                int1 = (HxOverrides.rshift(c, 16) & 255)
                x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                green = None
                try:
                    green = int(x1)
                except BaseException as _g:
                    None
                    green = None
                _hx_int = (HxOverrides.rshift(c1, 8) & 255)
                int1 = (HxOverrides.rshift(c, 8) & 255)
                x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                blue = None
                try:
                    blue = int(x1)
                except BaseException as _g:
                    None
                    blue = None
                _hx_int = (c1 & 255)
                int1 = (c & 255)
                x1 = (((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(blend1,"factor")) + (((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * ((1 - Reflect.field(blend1,"factor"))))))
                alpha = None
                try:
                    alpha = int(x1)
                except BaseException as _g:
                    None
                    alpha = None
                tmp1 = (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
            else:
                tmp1 = c
        tmp.set(x,y,tmp1)



class bitmap_PNGBitmap(bitmap_AbstractBitmap):
    _hx_class_name = "bitmap.PNGBitmap"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["load", "save", "copy"]
    _hx_statics = ["create"]
    _hx_interfaces = []
    _hx_super = bitmap_AbstractBitmap


    def __init__(self,w = None,h = None,f = None):
        super().__init__(w,h,f)

    def load(self,input,f = None):
        if (f is None):
            f = bitmap_PixelFormat.RGBA
        if ((f != bitmap_PixelFormat.RGBA) and ((f != bitmap_PixelFormat.ARGB))):
            raise haxe_Exception.thrown("Image format not supported")
        d = format_png_Reader(input).read()
        hdr = format_png_Tools.getHeader(d)
        self.width = hdr.width
        self.height = hdr.height
        self.format = f
        self.data = format_png_Tools.extract32(d)
        format_png_Tools.reverseBytes(self.data)
        if (self.format == bitmap_PixelFormat.RGBA):
            _hx_bytes = self.data
            if (_hx_bytes is None):
                raise haxe_Exception.thrown("FAIL: bytes != null")
            actual = HxOverrides.mod(_hx_bytes.length, 4)
            if (actual != 0):
                raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + Std.string(0)) + ", actual: ") + Std.string(actual)) + ")"))
            length = _hx_bytes.length
            i = 0
            while (i < length):
                a = _hx_bytes.b[i]
                r = _hx_bytes.b[(i + 1)]
                g = _hx_bytes.b[(i + 2)]
                b = _hx_bytes.b[(i + 3)]
                _hx_bytes.b[i] = (r & 255)
                _hx_bytes.b[(i + 1)] = (g & 255)
                _hx_bytes.b[(i + 2)] = (b & 255)
                _hx_bytes.b[(i + 3)] = (a & 255)
                i = (i + 4)

    def save(self,output):
        copy = self.data.sub(0,self.data.length)
        if ((self.format is None) or ((self.format == bitmap_PixelFormat.RGBA))):
            if (copy is None):
                raise haxe_Exception.thrown("FAIL: bytes != null")
            actual = HxOverrides.mod(copy.length, 4)
            if (actual != 0):
                raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + Std.string(0)) + ", actual: ") + Std.string(actual)) + ")"))
            length = copy.length
            i = 0
            while (i < length):
                r = copy.b[i]
                g = copy.b[(i + 1)]
                b = copy.b[(i + 2)]
                a = copy.b[(i + 3)]
                copy.b[i] = (a & 255)
                copy.b[(i + 1)] = (r & 255)
                copy.b[(i + 2)] = (g & 255)
                copy.b[(i + 3)] = (b & 255)
                i = (i + 4)
        data = format_png_Tools.build32ARGB(self.width,self.height,copy)
        format_png_Writer(output).write(data)

    def copy(self,r):
        if (r is None):
            r = self.bounds()
        b = bitmap_PNGBitmap(r.width,r.height)
        b.noRangeCheck = self.noRangeCheck
        b.copyFrom(self,_hx_AnonObject({'x': r.x, 'y': r.y}),_hx_AnonObject({'x': 0, 'y': 0, 'width': r.width, 'height': r.height}))
        return b

    @staticmethod
    def create(input,format = None):
        bitmap = bitmap_PNGBitmap()
        bitmap.load(input,format)
        return bitmap



class bitmap_PixelFormatUtil:
    _hx_class_name = "bitmap.PixelFormatUtil"
    __slots__ = ()
    _hx_statics = ["argbToRgba", "rgbaToArgb", "brgaToRgba", "rgbaToBgra"]

    @staticmethod
    def argbToRgba(_hx_bytes):
        if (_hx_bytes is None):
            raise haxe_Exception.thrown("FAIL: bytes != null")
        actual = HxOverrides.mod(_hx_bytes.length, 4)
        if (actual != 0):
            raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + Std.string(0)) + ", actual: ") + Std.string(actual)) + ")"))
        length = _hx_bytes.length
        i = 0
        while (i < length):
            a = _hx_bytes.b[i]
            r = _hx_bytes.b[(i + 1)]
            g = _hx_bytes.b[(i + 2)]
            b = _hx_bytes.b[(i + 3)]
            _hx_bytes.b[i] = (r & 255)
            _hx_bytes.b[(i + 1)] = (g & 255)
            _hx_bytes.b[(i + 2)] = (b & 255)
            _hx_bytes.b[(i + 3)] = (a & 255)
            i = (i + 4)
        return _hx_bytes

    @staticmethod
    def rgbaToArgb(_hx_bytes):
        if (_hx_bytes is None):
            raise haxe_Exception.thrown("FAIL: bytes != null")
        actual = HxOverrides.mod(_hx_bytes.length, 4)
        if (actual != 0):
            raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + Std.string(0)) + ", actual: ") + Std.string(actual)) + ")"))
        length = _hx_bytes.length
        i = 0
        while (i < length):
            r = _hx_bytes.b[i]
            g = _hx_bytes.b[(i + 1)]
            b = _hx_bytes.b[(i + 2)]
            a = _hx_bytes.b[(i + 3)]
            _hx_bytes.b[i] = (a & 255)
            _hx_bytes.b[(i + 1)] = (r & 255)
            _hx_bytes.b[(i + 2)] = (g & 255)
            _hx_bytes.b[(i + 3)] = (b & 255)
            i = (i + 4)
        return _hx_bytes

    @staticmethod
    def brgaToRgba(_hx_bytes):
        if (_hx_bytes is None):
            raise haxe_Exception.thrown("FAIL: bytes != null")
        actual = HxOverrides.mod(_hx_bytes.length, 4)
        if (actual != 0):
            raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + Std.string(0)) + ", actual: ") + Std.string(actual)) + ")"))
        length = _hx_bytes.length
        i = 0
        while (i < length):
            b = _hx_bytes.b[i]
            r = _hx_bytes.b[(i + 1)]
            g = _hx_bytes.b[(i + 2)]
            a = _hx_bytes.b[(i + 3)]
            _hx_bytes.b[i] = (r & 255)
            _hx_bytes.b[(i + 1)] = (g & 255)
            _hx_bytes.b[(i + 2)] = (b & 255)
            _hx_bytes.b[(i + 3)] = (a & 255)
            i = (i + 4)
        return _hx_bytes

    @staticmethod
    def rgbaToBgra(_hx_bytes):
        if (_hx_bytes is None):
            raise haxe_Exception.thrown("FAIL: bytes != null")
        actual = HxOverrides.mod(_hx_bytes.length, 4)
        if (actual != 0):
            raise haxe_Exception.thrown((((("FAIL: values are not equal (expected: " + Std.string(0)) + ", actual: ") + Std.string(actual)) + ")"))
        length = _hx_bytes.length
        i = 0
        while (i < length):
            r = _hx_bytes.b[i]
            g = _hx_bytes.b[(i + 1)]
            b = _hx_bytes.b[(i + 2)]
            a = _hx_bytes.b[(i + 3)]
            _hx_bytes.b[i] = (b & 255)
            _hx_bytes.b[(i + 1)] = (g & 255)
            _hx_bytes.b[(i + 2)] = (r & 255)
            _hx_bytes.b[(i + 3)] = (a & 255)
            i = (i + 4)
        return _hx_bytes

class bitmap_Blend(Enum):
    __slots__ = ()
    _hx_class_name = "bitmap.Blend"
    _hx_constructs = ["alpha", "mean", "none"]
bitmap_Blend.alpha = bitmap_Blend("alpha", 0, ())
bitmap_Blend.mean = bitmap_Blend("mean", 1, ())
bitmap_Blend.none = bitmap_Blend("none", 2, ())

class bitmap_PixelFormat(Enum):
    __slots__ = ()
    _hx_class_name = "bitmap.PixelFormat"
    _hx_constructs = ["RGBA", "ARGB"]
bitmap_PixelFormat.RGBA = bitmap_PixelFormat("RGBA", 0, ())
bitmap_PixelFormat.ARGB = bitmap_PixelFormat("ARGB", 1, ())

class bitmap_Background(Enum):
    __slots__ = ()
    _hx_class_name = "bitmap.Background"
    _hx_constructs = ["bg", "none"]
bitmap_Background.bg = bitmap_Background("bg", 0, ())
bitmap_Background.none = bitmap_Background("none", 1, ())


class bitmap_Util:
    _hx_class_name = "bitmap.Util"
    __slots__ = ()
    _hx_statics = ["clamp", "printRectangle", "min", "max", "abs", "sgn", "toRadians", "toDegrees", "parseIntOrThrow", "random", "randomIntArray", "randomRectangle", "multiply", "dist", "urlToBase64", "randomArrayItem", "minMaxElements"]

    @staticmethod
    def clamp(value,_hx_min,_hx_max):
        if (value < _hx_min):
            return _hx_min
        elif (value > _hx_max):
            return _hx_max
        else:
            return value

    @staticmethod
    def printRectangle(r):
        return (((((((("Rectangle(" + Std.string(r.x)) + ", ") + Std.string(r.y)) + ", ") + Std.string(r.width)) + ", ") + Std.string(r.height)) + ")")

    @staticmethod
    def min(first,second):
        if (first < second):
            return first
        else:
            return second

    @staticmethod
    def max(first,second):
        if (first > second):
            return first
        else:
            return second

    @staticmethod
    def abs(value):
        if (value < 0):
            return -value
        else:
            return value

    @staticmethod
    def sgn(value):
        if (value < 0):
            return -1
        elif (value > 0):
            return 1
        else:
            return 0

    @staticmethod
    def toRadians(degrees):
        return ((degrees * Math.PI) / 180)

    @staticmethod
    def toDegrees(radians):
        return ((radians * 180) / Math.PI)

    @staticmethod
    def parseIntOrThrow(s):
        i = Std.parseInt(s)
        if python_lib_Math.isnan(i):
            raise haxe_Exception.thrown((("Expected " + ("null" if s is None else s)) + " to be parsable as integer"))
        return Math.floor((i + 0.5))

    @staticmethod
    def random(lower,upper):
        return Math.floor((((((upper - lower)) * python_lib_Random.random()) + lower) + 0.5))

    @staticmethod
    def randomIntArray(length,lower,upper,noRepeat = None):
        if (noRepeat is None):
            noRepeat = False
        if (length >= (((upper - lower) + 1))):
            raise haxe_Exception.thrown("FAIL: length < upper - lower + 1")
        a = []
        r = Math.floor((((((upper - lower)) * python_lib_Random.random()) + lower) + 0.5))
        _g = 0
        while (_g < length):
            _g = (_g + 1)
            def _hx_local_1(n):
                return (n == r)
            while (len(list(filter(_hx_local_1,a))) != 0):
                r = Math.floor((((((upper - lower)) * python_lib_Random.random()) + lower) + 0.5))
            a.append(r)
        return a

    @staticmethod
    def randomRectangle(r):
        w = (r.width / 2)
        h = (r.height / 2)
        return _hx_AnonObject({'x': Math.floor(((w * python_lib_Random.random()) + 0.5)), 'y': Math.floor(((h * python_lib_Random.random()) + 0.5)), 'width': Math.floor(((w * python_lib_Random.random()) + 0.5)), 'height': Math.floor(((h * python_lib_Random.random()) + 0.5))})

    @staticmethod
    def multiply(a,b):
        aNumRows = len(a)
        aNumCols = len((a[0] if 0 < len(a) else None))
        bNumRows = len(b)
        bNumCols = len((b[0] if 0 < len(b) else None))
        _g = []
        _g1 = 0
        while (_g1 < aNumRows):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append([(i * 1.0)])
        _g1 = 0
        while (_g1 < aNumRows):
            r = _g1
            _g1 = (_g1 + 1)
            _g2 = []
            _g3 = 0
            while (_g3 < bNumRows):
                i = _g3
                _g3 = (_g3 + 1)
                _g2.append((i * 1.0))
            python_internal_ArrayImpl._set(_g, r, _g2)
            _g4 = 0
            while (_g4 < bNumCols):
                c = _g4
                _g4 = (_g4 + 1)
                python_internal_ArrayImpl._set((_g[r] if r >= 0 and r < len(_g) else None), c, 0.0)
                _g5 = 0
                while (_g5 < aNumCols):
                    i1 = _g5
                    _g5 = (_g5 + 1)
                    _hx_local_0 = (_g[r] if r >= 0 and r < len(_g) else None)
                    _hx_local_1 = c
                    _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
                    python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 + ((python_internal_ArrayImpl._get((a[r] if r >= 0 and r < len(a) else None), i1) * python_internal_ArrayImpl._get((b[i1] if i1 >= 0 and i1 < len(b) else None), c)))))
                    (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
        return _g

    @staticmethod
    def dist(x,y):
        if (x < y):
            return (y - x)
        else:
            return (x - y)

    @staticmethod
    def urlToBase64(s):
        return HxString.substring(s,(s.find(";base64,") + len(";base64,")),None)

    @staticmethod
    def randomArrayItem(a):
        if (not (((a is not None) and ((len(a) > 0))))):
            raise haxe_Exception.thrown("FAIL: a != null && a.length > 0")
        return python_internal_ArrayImpl._get(a, Math.floor(((((len(a) - 1)) * python_lib_Random.random()) + 0.5)))

    @staticmethod
    def minMaxElements(a):
        if ((a is None) or ((len(a) == 0))):
            return _hx_AnonObject({'min': 0, 'max': 0})
        _hx_min = (a[0] if 0 < len(a) else None)
        _hx_max = (a[0] if 0 < len(a) else None)
        _g = 0
        while (_g < len(a)):
            value = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            if (_hx_min > value):
                _hx_min = value
            if (_hx_max < value):
                _hx_max = value
        return _hx_AnonObject({'min': _hx_min, 'max': _hx_max})


class bitmap_support_Pako:
    _hx_class_name = "bitmap.support.Pako"
    __slots__ = ()
    _hx_statics = ["js"]


class bitmap_support_StructureTools:
    _hx_class_name = "bitmap.support.StructureTools"
    __slots__ = ()
    _hx_statics = ["assign"]

    @staticmethod
    def assign(o1,o2,o3):
        fields = ((python_Boot.fields(o1) + python_Boot.fields(o2)) + python_Boot.fields(o3))
        _g = 0
        while (_g < len(fields)):
            f = (fields[_g] if _g >= 0 and _g < len(fields) else None)
            _g = (_g + 1)
            v = ((Reflect.field(o3,f) or Reflect.field(o2,f)) or Reflect.field(o1,f))
            setattr(o1,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),v)
        return o1


class bitmap_support_ZipSupport:
    _hx_class_name = "bitmap.support.ZipSupport"
    __slots__ = ()
    _hx_statics = ["haxeZipCompressJsSupportOnce", "haxeZipCompressJsSupport"]

    @staticmethod
    def haxeZipCompressJsSupport():
        pass


class bitmap_transformation_Affine:
    _hx_class_name = "bitmap.transformation.Affine"
    __slots__ = ("a", "b", "c", "d", "e", "f")
    _hx_fields = ["a", "b", "c", "d", "e", "f"]
    _hx_methods = ["applyToPoint", "transform", "transformMatrix", "assign", "getMatrix", "isIdentity", "interpolate", "rotate", "rotateDeg", "translate", "translateX", "translateY", "flipY", "flipX", "scale", "scaleX", "scaleY", "skew", "skewX", "skewY", "applyToPoints", "applyToArray"]
    _hx_statics = ["identity"]

    def __init__(self):
        matrix = bitmap_transformation_Affine.identity()
        self.a = matrix.a
        self.b = matrix.b
        self.c = matrix.c
        self.d = matrix.d
        self.e = matrix.e
        self.f = matrix.f

    def applyToPoint(self,x,y):
        return _hx_AnonObject({'x': (((x * self.a) + ((y * self.c))) + self.e), 'y': (((x * self.b) + ((y * self.d))) + self.f)})

    def transform(self,o):
        matrix = (Reflect.field(o,"matrix") if ((Reflect.field(o,"matrix") is not None)) else Reflect.field(o,"affine").getMatrix())
        self.a = matrix.a
        self.b = matrix.b
        self.c = matrix.c
        self.d = matrix.d
        self.e = matrix.e
        self.f = matrix.f
        output = (Reflect.field(o,"output") if (((Reflect.field(o,"output") is not None) and ((Reflect.field(o,"output") != Reflect.field(o,"bitmap"))))) else Reflect.field(o,"bitmap").clone((None if ((Reflect.field(o,"bg") == bitmap_Background.none)) else True)))
        region = (output.bounds() if ((Reflect.field(o,"region") is None)) else Reflect.field(o,"region"))
        _g = region.y
        _g1 = region.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = region.x
            _g3 = region.width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                p_x = (((x * self.a) + ((y * self.c))) + self.e)
                p_y = (((x * self.b) + ((y * self.d))) + self.f)
                if ((((p_x >= 0) and ((p_x < output.width))) and ((p_y >= 0))) and ((p_y < output.height))):
                    x2 = Math.floor(p_x)
                    y2 = Math.floor(p_y)
                    if (Reflect.field(o,"precision") and ((Reflect.field(o,"bg") != bitmap_Background.none))):
                        if (output.get(x2,y2,True) != Reflect.field(o,"bitmap").bg):
                            x2 = Math.floor((p_x + 0.5))
                        if (output.get(x2,y2,True) != Reflect.field(o,"bitmap").bg):
                            y2 = Math.floor((p_y + 0.5))
                    output.set(x2,y2,Reflect.field(o,"bitmap").get(x,y),True)
        if (Reflect.field(o,"output") == Reflect.field(o,"bitmap")):
            Reflect.field(o,"output").copyFrom(output,region,region)
        return _hx_AnonObject({'bitmap': output, 'affine': self})

    def transformMatrix(self,a2,b2,c2,d2,e2,f2):
        a1 = self.a
        b1 = self.b
        c1 = self.c
        d1 = self.d
        self.a = ((a1 * a2) + ((c1 * b2)))
        self.b = ((b1 * a2) + ((d1 * b2)))
        self.c = ((a1 * c2) + ((c1 * d2)))
        self.d = ((b1 * c2) + ((d1 * d2)))
        self.e = (((a1 * e2) + ((c1 * f2))) + self.e)
        self.f = (((b1 * e2) + ((d1 * f2))) + self.f)
        return self

    def assign(self,m):
        self.a = m.a
        self.b = m.b
        self.c = m.c
        self.d = m.d
        self.e = m.e
        self.f = m.f
        return self

    def getMatrix(self):
        return _hx_AnonObject({'a': self.a, 'b': self.b, 'c': self.c, 'd': self.d, 'e': self.e, 'f': self.f})

    def isIdentity(self):
        if (((((self.a == 1) and ((self.b == 0))) and ((self.c == 0))) and ((self.d == 1))) and ((self.e == 0))):
            return (self.f == 0)
        else:
            return False

    def interpolate(self,m2,t):
        m = _hx_AnonObject({'a': 0.0, 'b': 0.0, 'c': 0.0, 'd': 0.0, 'e': 0.0, 'f': 0.0})
        m.a = (self.a + ((((m2.a - self.a)) * t)))
        m.b = (self.b + ((((m2.b - self.b)) * t)))
        m.c = (self.c + ((((m2.c - self.c)) * t)))
        m.d = (self.d + ((((m2.d - self.d)) * t)))
        m.e = (self.e + ((((m2.e - self.e)) * t)))
        m.f = (self.f + ((((m2.f - self.f)) * t)))
        return m

    def rotate(self,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        return self.transformMatrix(cos,sin,-sin,cos,0,0)

    def rotateDeg(self,angle):
        return self.rotate((angle * 0.017453292519943295))

    def translate(self,tx,ty):
        return self.transformMatrix(1,0,0,1,tx,ty)

    def translateX(self,tx):
        return self.transformMatrix(1,0,0,1,tx,0)

    def translateY(self,ty):
        return self.transformMatrix(1,0,0,1,0,ty)

    def flipY(self):
        return self.transformMatrix(1.0,0.0,0.0,-1.0,0.0,0.0)

    def flipX(self):
        return self.transformMatrix(-1.0,0.0,0.0,1.0,0.0,0.0)

    def scale(self,sx,sy):
        self.transformMatrix(sx,0,0,sy,0,0)
        return self

    def scaleX(self,sx):
        self.transformMatrix(sx,0,0,1,0,0)
        return self

    def scaleY(self,sy):
        return self.transformMatrix(1,0,0,sy,0,0)

    def skew(self,sx,sy):
        return self.transformMatrix(1,sy,sx,1,0,0)

    def skewX(self,sx):
        return self.transformMatrix(1,0,sx,1,0,0)

    def skewY(self,sy):
        return self.transformMatrix(1,sy,0,1,0,0)

    def applyToPoints(self,points):
        i = 0
        p = None
        mxPoints = []
        l = len(points)
        while (i < l):
            p2 = i
            i = (i + 1)
            p21 = (points[p2] if p2 >= 0 and p2 < len(points) else None)
            x = p21.x
            y = p21.y
            p = _hx_AnonObject({'x': (((x * self.a) + ((y * self.c))) + self.e), 'y': (((x * self.b) + ((y * self.d))) + self.f)})
            mxPoints.append(p)
        return mxPoints

    def applyToArray(self,points):
        i = 0
        p_y = None
        p_x = None
        l = (points.byteLength >> 2)
        size = (l * 4)
        mxPoints = haxe_io_ArrayBufferViewImpl(haxe_io_Bytes.alloc(size),0,size)
        while (i < l):
            _this = points.bytes
            pos = (((i << 2)) + points.byteOffset)
            v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            x = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _this1 = points.bytes
            pos1 = ((((i + 1) << 2)) + points.byteOffset)
            v1 = (((_this1.b[pos1] | ((_this1.b[(pos1 + 1)] << 8))) | ((_this1.b[(pos1 + 2)] << 16))) | ((_this1.b[(pos1 + 3)] << 24)))
            y = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            p_x = (((x * self.a) + ((y * self.c))) + self.e)
            p_y = (((x * self.b) + ((y * self.d))) + self.f)
            index = i
            i = (i + 1)
            value = Math.floor((p_x + 0.5))
            if ((index >= 0) and ((index < ((mxPoints.byteLength >> 2))))):
                _this2 = mxPoints.bytes
                pos2 = (((index << 2)) + mxPoints.byteOffset)
                _this2.b[pos2] = (value & 255)
                _this2.b[(pos2 + 1)] = ((value >> 8) & 255)
                _this2.b[(pos2 + 2)] = ((value >> 16) & 255)
                _this2.b[(pos2 + 3)] = (HxOverrides.rshift(value, 24) & 255)
            index1 = i
            i = (i + 1)
            value1 = Math.floor((p_y + 0.5))
            if ((index1 >= 0) and ((index1 < ((mxPoints.byteLength >> 2))))):
                _this3 = mxPoints.bytes
                pos3 = (((index1 << 2)) + mxPoints.byteOffset)
                _this3.b[pos3] = (value1 & 255)
                _this3.b[(pos3 + 1)] = ((value1 >> 8) & 255)
                _this3.b[(pos3 + 2)] = ((value1 >> 16) & 255)
                _this3.b[(pos3 + 3)] = (HxOverrides.rshift(value1, 24) & 255)
        return mxPoints

    @staticmethod
    def identity():
        return _hx_AnonObject({'a': 1.0, 'b': 0.0, 'c': 0.0, 'd': 1.0, 'e': 0.0, 'f': 0.0})



class bitmap_transformation_Colors:
    _hx_class_name = "bitmap.transformation.Colors"
    __slots__ = ("bitmap",)
    _hx_fields = ["bitmap"]
    _hx_methods = ["blend", "filter", "grayScale", "sepia"]

    def __init__(self,b):
        self.bitmap = b

    def blend(self,o):
        raise haxe_Exception.thrown("todo")

    def filter(self,o):
        Reflect.setField(o,"bitmap",(self.bitmap if ((Reflect.field(o,"bitmap") is None)) else Reflect.field(o,"bitmap")))
        output = (Reflect.field(o,"bitmap").clone() if ((Reflect.field(o,"output") is None)) else Reflect.field(o,"output"))
        region = (output.bounds() if ((Reflect.field(o,"region") is None)) else Reflect.field(o,"region"))
        _g = region.y
        _g1 = region.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = region.x
            _g3 = region.width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                c = Reflect.field(o,"bitmap").get(x,y)
                Reflect.setField(o,"x",x)
                Reflect.setField(o,"y",y)
                c2 = None
                if (Reflect.field(o,"fn") is not None):
                    c2 = Reflect.field(o,"fn")(c,o)
                else:
                    Reflect.setField(o,"red",(_hx_AnonObject({'a': 1.0, 'c': 0.0}) if ((Reflect.field(o,"red") is None)) else Reflect.field(o,"red")))
                    Reflect.setField(o,"green",(_hx_AnonObject({'a': 1.0, 'c': 0.0}) if ((Reflect.field(o,"green") is None)) else Reflect.field(o,"green")))
                    Reflect.setField(o,"blue",(_hx_AnonObject({'a': 1.0, 'c': 0.0}) if ((Reflect.field(o,"blue") is None)) else Reflect.field(o,"blue")))
                    Reflect.setField(o,"alpha",(_hx_AnonObject({'a': 1.0, 'c': 0.0}) if ((Reflect.field(o,"alpha") is None)) else Reflect.field(o,"alpha")))
                    _hx_int = (HxOverrides.rshift(c, 24) & 255)
                    red = Math.floor(((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) * Reflect.field(o,"red").a) + Reflect.field(o,"red").c) + 0.5))
                    int1 = (HxOverrides.rshift(c, 16) & 255)
                    green = Math.floor(((((((4294967296.0 + int1) if ((int1 < 0)) else (int1 + 0.0))) * Reflect.field(o,"green").a) + Reflect.field(o,"green").c) + 0.5))
                    int2 = (HxOverrides.rshift(c, 8) & 255)
                    blue = Math.floor(((((((4294967296.0 + int2) if ((int2 < 0)) else (int2 + 0.0))) * Reflect.field(o,"blue").a) + Reflect.field(o,"blue").c) + 0.5))
                    int3 = (c & 255)
                    alpha = Math.floor(((((((4294967296.0 + int3) if ((int3 < 0)) else (int3 + 0.0))) * Reflect.field(o,"alpha").a) + Reflect.field(o,"alpha").c) + 0.5))
                    c2 = (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
                c21 = None
                if (Reflect.field(o,"blend") is None):
                    c21 = c2
                else:
                    blend = Reflect.field(o,"blend")
                    if (blend is None):
                        blend = _hx_AnonObject({'type': bitmap_Blend.mean, 'factor': 0.5})
                    Reflect.setField(blend,"factor",(0.5 if ((Reflect.field(blend,"factor") is None)) else Reflect.field(blend,"factor")))
                    if (blend.type == bitmap_Blend.alpha):
                        c21 = c2
                    elif (blend.type == bitmap_Blend.mean):
                        int4 = (HxOverrides.rshift(c, 24) & 255)
                        int5 = (HxOverrides.rshift(c2, 24) & 255)
                        x1 = (((((4294967296.0 + int4) if ((int4 < 0)) else (int4 + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int5) if ((int5 < 0)) else (int5 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
                        red1 = None
                        try:
                            red1 = int(x1)
                        except BaseException as _g4:
                            None
                            red1 = None
                        int6 = (HxOverrides.rshift(c, 16) & 255)
                        int7 = (HxOverrides.rshift(c2, 16) & 255)
                        x2 = (((((4294967296.0 + int6) if ((int6 < 0)) else (int6 + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int7) if ((int7 < 0)) else (int7 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
                        green1 = None
                        try:
                            green1 = int(x2)
                        except BaseException as _g5:
                            None
                            green1 = None
                        int8 = (HxOverrides.rshift(c, 8) & 255)
                        int9 = (HxOverrides.rshift(c2, 8) & 255)
                        x3 = (((((4294967296.0 + int8) if ((int8 < 0)) else (int8 + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int9) if ((int9 < 0)) else (int9 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
                        blue1 = None
                        try:
                            blue1 = int(x3)
                        except BaseException as _g6:
                            None
                            blue1 = None
                        int10 = (c & 255)
                        int11 = (c2 & 255)
                        x4 = (((((4294967296.0 + int10) if ((int10 < 0)) else (int10 + 0.0))) * Reflect.field(blend,"factor")) + (((((4294967296.0 + int11) if ((int11 < 0)) else (int11 + 0.0))) * ((1 - Reflect.field(blend,"factor"))))))
                        alpha1 = None
                        try:
                            alpha1 = int(x4)
                        except BaseException as _g7:
                            None
                            alpha1 = None
                        c21 = (((((((0 if ((red1 < 0)) else (255 if ((red1 > 255)) else red1))) << 24)) + ((((0 if ((green1 < 0)) else (255 if ((green1 > 255)) else green1))) << 16))) + ((((0 if ((blue1 < 0)) else (255 if ((blue1 > 255)) else blue1))) << 8))) + ((0 if ((alpha1 < 0)) else (255 if ((alpha1 > 255)) else alpha1))))
                    else:
                        c21 = c2
                output.set(x,y,c21)
        return output

    def grayScale(self,o = None):
        if (o is None):
            o = _hx_AnonObject({'bitmap': self.bitmap})
        def _hx_local_1():
            def _hx_local_0(c,o = None):
                _hx_int = ((((HxOverrides.rshift(c, 24) & 255)) + ((HxOverrides.rshift(c, 16) & 255))) + ((HxOverrides.rshift(c, 8) & 255)))
                gray = Math.floor((((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) / 3.) + 0.5))
                alpha = (c & 255)
                return (((((((0 if ((gray < 0)) else (255 if ((gray > 255)) else gray))) << 24)) + ((((0 if ((gray < 0)) else (255 if ((gray > 255)) else gray))) << 16))) + ((((0 if ((gray < 0)) else (255 if ((gray > 255)) else gray))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
            return self.filter(_hx_AnonObject({'fn': _hx_local_0, 'bitmap': ((_hx_AnonObject({'bitmap': self.bitmap}) if ((o is None)) else o)).bitmap}))
        return _hx_local_1()

    def sepia(self,o = None):
        if (o is None):
            o = _hx_AnonObject({'bitmap': self.bitmap, 'sepiaIntensity': 30})
        def _hx_local_2():
            def _hx_local_1(c,o2 = None):
                _hx_int = ((((HxOverrides.rshift(c, 24) & 255)) + ((HxOverrides.rshift(c, 16) & 255))) + ((HxOverrides.rshift(c, 8) & 255)))
                gray = ((((4294967296.0 + _hx_int) if ((_hx_int < 0)) else (_hx_int + 0.0))) / 3.)
                r = gray
                g = gray
                b = gray
                r = (gray + 40)
                g = (gray + 20)
                if (r > 255):
                    r = 255
                if (g > 255):
                    g = 255
                if (gray > 255):
                    b = 255
                b = (b - (30 if ((Reflect.field(o,"sepiaIntensity") is None)) else Reflect.field(o,"sepiaIntensity")))
                if (b < 0):
                    b = 0
                if (b > 255):
                    b = 255
                red = Math.floor((r + 0.5))
                green = Math.floor((g + 0.5))
                blue = Math.floor((b + 0.5))
                alpha = (c & 255)
                return (((((((0 if ((red < 0)) else (255 if ((red > 255)) else red))) << 24)) + ((((0 if ((green < 0)) else (255 if ((green > 255)) else green))) << 16))) + ((((0 if ((blue < 0)) else (255 if ((blue > 255)) else blue))) << 8))) + ((0 if ((alpha < 0)) else (255 if ((alpha > 255)) else alpha))))
            return self.filter(_hx_AnonObject({'fn': _hx_local_1, 'bitmap': ((_hx_AnonObject({'bitmap': self.bitmap}) if ((o is None)) else o)).bitmap}))
        return _hx_local_2()



class bitmap_transformation_Convolution:
    _hx_class_name = "bitmap.transformation.Convolution"
    __slots__ = ()
    _hx_statics = ["convolve", "blur", "blurKernel", "fBlur", "sharp"]

    @staticmethod
    def convolve(o):
        if (Reflect.field(o,"bitmap") == Reflect.field(o,"output")):
            raise haxe_Exception.thrown("FAIL: o.bitmap != o.output")
        if (not (((Reflect.field(o,"output") is None) or (((Reflect.field(o,"bitmap").width == Reflect.field(o,"output").width) and ((Reflect.field(o,"bitmap").height == Reflect.field(o,"output").height))))))):
            raise haxe_Exception.thrown("FAIL: o.output == null || o.bitmap.width == o.output.width && o.bitmap.height == o.output.height")
        output = (Reflect.field(o,"bitmap").clone() if ((Reflect.field(o,"output") is None)) else Reflect.field(o,"output"))
        data = Reflect.field(o,"bitmap")
        width = Reflect.field(o,"bitmap").width
        matrix = o.kernel
        w = len((matrix[0] if 0 < len(matrix) else None))
        h = len(matrix)
        half = Math.floor((h / 2))
        factor = (1.0 if ((Reflect.field(o,"factor") is None)) else Reflect.field(o,"factor"))
        bias = (0.0 if ((Reflect.field(o,"bias") is None)) else Reflect.field(o,"bias"))
        region = (output.bounds() if ((Reflect.field(o,"region") is None)) else Reflect.field(o,"region"))
        _g = region.y
        _g1 = region.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = region.x
            _g3 = region.width
            while (_g2 < _g3):
                x = _g2
                _g2 = (_g2 + 1)
                px = (((width * y) + x) << 2)
                r = 0.0
                g = 0.0
                b = 0.0
                _g4 = 0
                while (_g4 < h):
                    cy = _g4
                    _g4 = (_g4 + 1)
                    _g5 = 0
                    while (_g5 < w):
                        cx = _g5
                        _g5 = (_g5 + 1)
                        cpx = Math.floor(((((((y + ((cy - half)))) * width) + ((x + ((cx - half)))))) * 4))
                        ir = (data.data.b[cpx] if (((cpx >= 0) and ((cpx < data.data.length)))) else 0)
                        ig = (data.data.b[(cpx + 1)] if (((cpx >= 0) and (((cpx + 1) < data.data.length)))) else 0)
                        ib = (data.data.b[(cpx + 2)] if (((cpx >= 0) and (((cpx + 2) < data.data.length)))) else 0)
                        if (ir is None):
                            ir = 0
                        if (ig is None):
                            ig = 0
                        if (ib is None):
                            ib = 0
                        r = (r + ((ir * python_internal_ArrayImpl._get((matrix[cy] if cy >= 0 and cy < len(matrix) else None), cx))))
                        g = (g + ((ig * python_internal_ArrayImpl._get((matrix[cy] if cy >= 0 and cy < len(matrix) else None), cx))))
                        b = (b + ((ib * python_internal_ArrayImpl._get((matrix[cy] if cy >= 0 and cy < len(matrix) else None), cx))))
                _this = output.data
                value = Math.floor((((factor * r) + bias) + 0.5))
                _this.b[px] = (((0 if ((value < 0)) else (255 if ((value > 255)) else value))) & 255)
                _this1 = output.data
                value1 = Math.floor((((factor * g) + bias) + 0.5))
                _this1.b[(px + 1)] = (((0 if ((value1 < 0)) else (255 if ((value1 > 255)) else value1))) & 255)
                _this2 = output.data
                value2 = Math.floor((((factor * b) + bias) + 0.5))
                _this2.b[(px + 2)] = (((0 if ((value2 < 0)) else (255 if ((value2 > 255)) else value2))) & 255)
                _this3 = output.data
                v = data.data.b[(px + 3)]
                _this3.b[(px + 3)] = (v & 255)
        return output

    @staticmethod
    def blur(size = None,bias = None,output = None):
        if (size is None):
            size = 3
        if (bias is None):
            bias = 0.0
        return _hx_AnonObject({'kernel': bitmap_transformation_Convolution.blurKernel(size,bias), 'bias': bias, 'factor': (1 / ((size * size))), 'bitmap': None, 'output': output, 'region': None})

    @staticmethod
    def blurKernel(size = None,bias = None):
        if (size is None):
            size = 3
        if (bias is None):
            bias = 0.0
        _g = []
        _g1 = 0
        while (_g1 < size):
            _g1 = (_g1 + 1)
            _g2 = []
            _g3 = 0
            while (_g3 < size):
                _g3 = (_g3 + 1)
                _g2.append(0.0)
            _g.append(_g2)
        _g1 = 0
        while (_g1 < size):
            i = _g1
            _g1 = (_g1 + 1)
            _g2 = 0
            while (_g2 < size):
                j = _g2
                _g2 = (_g2 + 1)
                python_internal_ArrayImpl._set((_g[i] if i >= 0 and i < len(_g) else None), j, 1.0)
        return _g

    @staticmethod
    def fBlur(size = None,bias = None,output = None):
        if (size is None):
            size = 4
        if (bias is None):
            bias = 0.0
        _g = []
        _g1 = 0
        while (_g1 < size):
            _g1 = (_g1 + 1)
            _g2 = []
            _g3 = 0
            while (_g3 < size):
                _g3 = (_g3 + 1)
                _g2.append(0.0)
            _g.append(_g2)
        _g1 = 0
        while (_g1 < size):
            i = _g1
            _g1 = (_g1 + 1)
            _g2 = 0
            while (_g2 < size):
                j = _g2
                _g2 = (_g2 + 1)
                if ((((i == 0) or ((j == 0))) or ((i == ((size - 1))))) or ((j == ((size - 1))))):
                    python_internal_ArrayImpl._set((_g[i] if i >= 0 and i < len(_g) else None), j, 1.0)
                else:
                    python_internal_ArrayImpl._set((_g[i] if i >= 0 and i < len(_g) else None), j, 0)
        return _hx_AnonObject({'kernel': _g, 'bias': bias, 'factor': (1 / ((size + 1))), 'bitmap': None, 'output': output, 'region': None})

    @staticmethod
    def sharp(factor = None,bias = None,output = None):
        if (factor is None):
            factor = 1.0
        if (bias is None):
            bias = 0.0
        return _hx_AnonObject({'kernel': [[-0.111111111111111105, -0.111111111111111105, -0.111111111111111105, -0.111111111111111105], [-0.111111111111111105, factor, factor, -0.111111111111111105], [-0.111111111111111105, factor, factor, -0.111111111111111105], [-0.111111111111111105, -0.111111111111111105, -0.111111111111111105, -0.111111111111111105]], 'bias': bias, 'factor': factor, 'bitmap': None, 'output': output, 'region': None})


class bitmap_transformation_Pixelize:
    _hx_class_name = "bitmap.transformation.Pixelize"
    __slots__ = ()
    _hx_methods = ["transform"]

    def __init__(self):
        pass

    def transform(self,t):
        b = (Reflect.field(t,"output") if ((Reflect.field(t,"output") is not None)) else Reflect.field(t,"bitmap").clone())
        a = Reflect.field(t,"bitmap")
        region2 = (a.bounds() if ((Reflect.field(t,"region") is None)) else Reflect.field(t,"region"))
        x = Math.floor(((region2.width / t.width) + 0.5))
        xStep = None
        try:
            xStep = int(x)
        except BaseException as _g:
            None
            xStep = None
        x = Math.floor(((region2.height / t.height) + 0.5))
        yStep = None
        try:
            yStep = int(x)
        except BaseException as _g:
            None
            yStep = None
        _g = 0
        _g1 = t.width
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = t.height
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                minXStep = (((region2.width - 1) - ((xStep * x))) if ((((xStep * x) + xStep) >= region2.width)) else xStep)
                minYStep = (((region2.height - 1) - ((yStep * y))) if ((((yStep * y) + yStep) >= region2.height)) else yStep)
                c = bitmap_ColorUtil.average(a,_hx_AnonObject({'x': ((xStep * x) + region2.x), 'y': ((yStep * y) + region2.y), 'width': minXStep, 'height': minYStep}),Reflect.field(t,"alpha"))
                b.draw.rectangle(_hx_AnonObject({'y': ((yStep * y) + region2.y), 'x': ((xStep * x) + region2.x), 'width': minXStep, 'height': minYStep, 'fill': True, 'c': c, 'blend': Reflect.field(t,"blend")}))
        return b



class bitmap_transformation_Transform:
    _hx_class_name = "bitmap.transformation.Transform"
    __slots__ = ("bitmap",)
    _hx_fields = ["bitmap"]
    _hx_methods = ["pixelize", "convolve", "affine"]

    def __init__(self,b):
        self.bitmap = b

    def pixelize(self,t):
        Reflect.setField(t,"bitmap",self.bitmap)
        return bitmap_transformation_Pixelize().transform(t)

    def convolve(self,t):
        Reflect.setField(t,"bitmap",self.bitmap)
        return bitmap_transformation_Convolution.convolve(t)

    def affine(self,t):
        if (not (((Reflect.field(t,"matrix") is not None) or ((Reflect.field(t,"affine") is not None))))):
            raise haxe_Exception.thrown("FAIL: t.matrix != null || t.affine != null")
        Reflect.setField(t,"bitmap",self.bitmap)
        affine = None
        if (Reflect.field(t,"affine") is None):
            affine = bitmap_transformation_Affine()
            affine.assign(Reflect.field(t,"matrix"))
        else:
            affine = Reflect.field(t,"affine")
        return affine.transform(t)


class format_png_Color(Enum):
    __slots__ = ()
    _hx_class_name = "format.png.Color"
    _hx_constructs = ["ColGrey", "ColTrue", "ColIndexed"]

    @staticmethod
    def ColGrey(alpha):
        return format_png_Color("ColGrey", 0, (alpha,))

    @staticmethod
    def ColTrue(alpha):
        return format_png_Color("ColTrue", 1, (alpha,))
format_png_Color.ColIndexed = format_png_Color("ColIndexed", 2, ())

class format_png_Chunk(Enum):
    __slots__ = ()
    _hx_class_name = "format.png.Chunk"
    _hx_constructs = ["CEnd", "CHeader", "CData", "CPalette", "CUnknown"]

    @staticmethod
    def CHeader(h):
        return format_png_Chunk("CHeader", 1, (h,))

    @staticmethod
    def CData(b):
        return format_png_Chunk("CData", 2, (b,))

    @staticmethod
    def CPalette(b):
        return format_png_Chunk("CPalette", 3, (b,))

    @staticmethod
    def CUnknown(id,data):
        return format_png_Chunk("CUnknown", 4, (id,data))
format_png_Chunk.CEnd = format_png_Chunk("CEnd", 0, ())


class format_png_Reader:
    _hx_class_name = "format.png.Reader"
    __slots__ = ("i", "checkCRC")
    _hx_fields = ["i", "checkCRC"]
    _hx_methods = ["read", "readHeader", "readChunk"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(True)
        self.checkCRC = True

    def read(self):
        if (self.i.readByte() != 137):
            raise haxe_Exception.thrown("Invalid header")
        if (self.i.readByte() != 80):
            raise haxe_Exception.thrown("Invalid header")
        if (self.i.readByte() != 78):
            raise haxe_Exception.thrown("Invalid header")
        if (self.i.readByte() != 71):
            raise haxe_Exception.thrown("Invalid header")
        if (self.i.readByte() != 13):
            raise haxe_Exception.thrown("Invalid header")
        if (self.i.readByte() != 10):
            raise haxe_Exception.thrown("Invalid header")
        if (self.i.readByte() != 26):
            raise haxe_Exception.thrown("Invalid header")
        if (self.i.readByte() != 10):
            raise haxe_Exception.thrown("Invalid header")
        l = haxe_ds_List()
        while True:
            c = self.readChunk()
            l.add(c)
            if (c == format_png_Chunk.CEnd):
                break
        return l

    def readHeader(self,i):
        i.set_bigEndian(True)
        width = i.readInt32()
        height = i.readInt32()
        colbits = i.readByte()
        color = i.readByte()
        color1 = None
        if (color == 0):
            color1 = format_png_Color.ColGrey(False)
        elif (color == 2):
            color1 = format_png_Color.ColTrue(False)
        elif (color == 3):
            color1 = format_png_Color.ColIndexed
        elif (color == 4):
            color1 = format_png_Color.ColGrey(True)
        elif (color == 6):
            color1 = format_png_Color.ColTrue(True)
        else:
            raise haxe_Exception.thrown(((("Unknown color model " + Std.string(color)) + ":") + Std.string(colbits)))
        compress = i.readByte()
        _hx_filter = i.readByte()
        if ((compress != 0) or ((_hx_filter != 0))):
            raise haxe_Exception.thrown("Invalid header")
        interlace = i.readByte()
        if ((interlace != 0) and ((interlace != 1))):
            raise haxe_Exception.thrown("Invalid header")
        return _hx_AnonObject({'width': width, 'height': height, 'colbits': colbits, 'color': color1, 'interlaced': (interlace == 1)})

    def readChunk(self):
        dataLen = self.i.readInt32()
        id = self.i.readString(4)
        data = self.i.read(dataLen)
        crc = self.i.readInt32()
        if self.checkCRC:
            c_crc = -1
            tmp = (((-1 ^ HxString.charCodeAt(id,0))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (16777215 ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,1))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,2))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp = (((c_crc ^ HxString.charCodeAt(id,3))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            _hx_len = data.length
            b = data.b
            _g = 0
            while (_g < _hx_len):
                i = _g
                _g = (_g + 1)
                tmp = (((c_crc ^ b[i])) & 255)
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
                c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            if (((c_crc ^ -1)) != crc):
                raise haxe_Exception.thrown("CRC check failure")
        if (id == "IDAT"):
            return format_png_Chunk.CData(data)
        elif (id == "IEND"):
            return format_png_Chunk.CEnd
        elif (id == "IHDR"):
            return format_png_Chunk.CHeader(self.readHeader(haxe_io_BytesInput(data)))
        elif (id == "PLTE"):
            return format_png_Chunk.CPalette(data)
        else:
            return format_png_Chunk.CUnknown(id,data)



class format_png_Tools:
    _hx_class_name = "format.png.Tools"
    __slots__ = ()
    _hx_statics = ["getHeader", "getPalette", "filter", "reverseBytes", "extractGrey", "extract32", "buildGrey", "buildIndexed", "buildRGB", "build32ARGB", "build32BGRA"]

    @staticmethod
    def getHeader(d):
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            if (val.index == 1):
                return val.params[0]
        raise haxe_Exception.thrown("Header not found")

    @staticmethod
    def getPalette(d):
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            if (val.index == 3):
                return val.params[0]
        return None

    @staticmethod
    def filter(data,x,y,stride,prev,p,numChannels = None):
        if (numChannels is None):
            numChannels = 4
        b = (0 if ((y == 0)) else data.b[(p - stride)])
        c = (0 if (((x == 0) or ((y == 0)))) else data.b[((p - stride) - numChannels)])
        k = ((prev + b) - c)
        pa = (k - prev)
        if (pa < 0):
            pa = -pa
        pb = (k - b)
        if (pb < 0):
            pb = -pb
        pc = (k - c)
        if (pc < 0):
            pc = -pc
        if ((pa <= pb) and ((pa <= pc))):
            return prev
        elif (pb <= pc):
            return b
        else:
            return c

    @staticmethod
    def reverseBytes(b):
        p = 0
        _g = 0
        _g1 = (b.length >> 2)
        while (_g < _g1):
            _g = (_g + 1)
            b1 = b.b[p]
            g = b.b[(p + 1)]
            r = b.b[(p + 2)]
            a = b.b[(p + 3)]
            p1 = p
            p = (p + 1)
            b.b[p1] = (a & 255)
            p2 = p
            p = (p + 1)
            b.b[p2] = (r & 255)
            p3 = p
            p = (p + 1)
            b.b[p3] = (g & 255)
            p4 = p
            p = (p + 1)
            b.b[p4] = (b1 & 255)

    @staticmethod
    def extractGrey(d):
        h = format_png_Tools.getHeader(d)
        grey = haxe_io_Bytes.alloc((h.width * h.height))
        data = None
        fullData = None
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            if (val.index == 2):
                _g = val.params[0]
                if (fullData is not None):
                    fullData.b.extend(_g.b)
                elif (data is None):
                    data = _g
                else:
                    fullData = haxe_io_BytesBuffer()
                    fullData.b.extend(data.b)
                    fullData.b.extend(_g.b)
                    data = None
        if (fullData is not None):
            data = fullData.getBytes()
        if (data is None):
            raise haxe_Exception.thrown("Data not found")
        data = format_tools_Inflate.run(data)
        r = 0
        w = 0
        _g = h.color
        if (_g.index == 0):
            _g1 = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            if (data.length < ((h.height * (((((2 if _g1 else 1)) * width) + 1))))):
                raise haxe_Exception.thrown("Not enough data")
            rinc = (2 if _g1 else 1)
            _g = 0
            _g1 = h.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                if (f == 0):
                    _g2 = 0
                    while (_g2 < width):
                        _g2 = (_g2 + 1)
                        v = data.b[r]
                        r = (r + rinc)
                        pos1 = w
                        w = (w + 1)
                        grey.b[pos1] = (v & 255)
                elif (f == 1):
                    cv = 0
                    _g3 = 0
                    while (_g3 < width):
                        _g3 = (_g3 + 1)
                        cv = (cv + data.b[r])
                        r = (r + rinc)
                        pos2 = w
                        w = (w + 1)
                        grey.b[pos2] = (cv & 255)
                elif (f == 2):
                    stride = (0 if ((y == 0)) else width)
                    _g4 = 0
                    while (_g4 < width):
                        _g4 = (_g4 + 1)
                        v1 = (data.b[r] + grey.b[(w - stride)])
                        r = (r + rinc)
                        pos3 = w
                        w = (w + 1)
                        grey.b[pos3] = (v1 & 255)
                elif (f == 3):
                    cv1 = 0
                    stride1 = (0 if ((y == 0)) else width)
                    _g5 = 0
                    while (_g5 < width):
                        _g5 = (_g5 + 1)
                        cv1 = ((data.b[r] + (((cv1 + grey.b[(w - stride1)]) >> 1))) & 255)
                        r = (r + rinc)
                        pos4 = w
                        w = (w + 1)
                        grey.b[pos4] = (cv1 & 255)
                elif (f == 4):
                    cv2 = 0
                    _g6 = 0
                    while (_g6 < width):
                        x = _g6
                        _g6 = (_g6 + 1)
                        b = (0 if ((y == 0)) else grey.b[(w - width)])
                        c = (0 if (((x == 0) or ((y == 0)))) else grey.b[((w - width) - 1)])
                        k = ((cv2 + b) - c)
                        pa = (k - cv2)
                        if (pa < 0):
                            pa = -pa
                        pb = (k - b)
                        if (pb < 0):
                            pb = -pb
                        pc = (k - c)
                        if (pc < 0):
                            pc = -pc
                        cv2 = ((((cv2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[r]) & 255)
                        r = (r + rinc)
                        pos5 = w
                        w = (w + 1)
                        grey.b[pos5] = (cv2 & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
        else:
            raise haxe_Exception.thrown("Unsupported color mode")
        return grey

    @staticmethod
    def extract32(d,_hx_bytes = None,flipY = None):
        h = format_png_Tools.getHeader(d)
        bgra = (haxe_io_Bytes.alloc(((h.width * h.height) * 4)) if ((_hx_bytes is None)) else _hx_bytes)
        data = None
        fullData = None
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            if (val.index == 2):
                _g = val.params[0]
                if (fullData is not None):
                    fullData.b.extend(_g.b)
                elif (data is None):
                    data = _g
                else:
                    fullData = haxe_io_BytesBuffer()
                    fullData.b.extend(data.b)
                    fullData.b.extend(_g.b)
                    data = None
        if (fullData is not None):
            data = fullData.getBytes()
        if (data is None):
            raise haxe_Exception.thrown("Data not found")
        data = format_tools_Inflate.run(data)
        r = 0
        w = 0
        lineDelta = 0
        if flipY:
            lineDelta = (-h.width * 8)
            w = (((h.height - 1)) * ((h.width * 4)))
        flipY1 = (-1 if flipY else 1)
        _g = h.color
        tmp = _g.index
        if (tmp == 0):
            _g1 = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            if (data.length < ((h.height * (((((2 if _g1 else 1)) * width) + 1))))):
                raise haxe_Exception.thrown("Not enough data")
            alphvaIdx = -1
            if (not _g1):
                _g1_head = d.h
                while (_g1_head is not None):
                    val = _g1_head.item
                    _g1_head = _g1_head.next
                    if (val.index == 4):
                        _g2 = val.params[1]
                        if (val.params[0] == "tRNS"):
                            if (_g2.length >= 2):
                                alphvaIdx = _g2.b[1]
                            break
            _g2 = 0
            _g3 = h.height
            while (_g2 < _g3):
                y = _g2
                _g2 = (_g2 + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                if (f == 0):
                    if _g1:
                        _g4 = 0
                        while (_g4 < width):
                            _g4 = (_g4 + 1)
                            pos1 = r
                            r = (r + 1)
                            v = data.b[pos1]
                            pos2 = w
                            w = (w + 1)
                            bgra.b[pos2] = (v & 255)
                            pos3 = w
                            w = (w + 1)
                            bgra.b[pos3] = (v & 255)
                            pos4 = w
                            w = (w + 1)
                            bgra.b[pos4] = (v & 255)
                            pos5 = w
                            w = (w + 1)
                            pos6 = r
                            r = (r + 1)
                            v1 = data.b[pos6]
                            bgra.b[pos5] = (v1 & 255)
                    else:
                        _g5 = 0
                        while (_g5 < width):
                            _g5 = (_g5 + 1)
                            pos7 = r
                            r = (r + 1)
                            v2 = data.b[pos7]
                            pos8 = w
                            w = (w + 1)
                            bgra.b[pos8] = (v2 & 255)
                            pos9 = w
                            w = (w + 1)
                            bgra.b[pos9] = (v2 & 255)
                            pos10 = w
                            w = (w + 1)
                            bgra.b[pos10] = (v2 & 255)
                            pos11 = w
                            w = (w + 1)
                            bgra.b[pos11] = (((0 if ((v2 == alphvaIdx)) else 255)) & 255)
                elif (f == 1):
                    cv = 0
                    ca = 0
                    if _g1:
                        _g6 = 0
                        while (_g6 < width):
                            _g6 = (_g6 + 1)
                            pos12 = r
                            r = (r + 1)
                            cv = (cv + data.b[pos12])
                            pos13 = w
                            w = (w + 1)
                            bgra.b[pos13] = (cv & 255)
                            pos14 = w
                            w = (w + 1)
                            bgra.b[pos14] = (cv & 255)
                            pos15 = w
                            w = (w + 1)
                            bgra.b[pos15] = (cv & 255)
                            pos16 = r
                            r = (r + 1)
                            ca = (ca + data.b[pos16])
                            pos17 = w
                            w = (w + 1)
                            bgra.b[pos17] = (ca & 255)
                    else:
                        _g7 = 0
                        while (_g7 < width):
                            _g7 = (_g7 + 1)
                            pos18 = r
                            r = (r + 1)
                            cv = (cv + data.b[pos18])
                            pos19 = w
                            w = (w + 1)
                            bgra.b[pos19] = (cv & 255)
                            pos20 = w
                            w = (w + 1)
                            bgra.b[pos20] = (cv & 255)
                            pos21 = w
                            w = (w + 1)
                            bgra.b[pos21] = (cv & 255)
                            pos22 = w
                            w = (w + 1)
                            bgra.b[pos22] = (((0 if ((cv == alphvaIdx)) else 255)) & 255)
                elif (f == 2):
                    stride = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if _g1:
                        _g8 = 0
                        while (_g8 < width):
                            _g8 = (_g8 + 1)
                            pos23 = r
                            r = (r + 1)
                            v3 = (data.b[pos23] + bgra.b[(w - stride)])
                            pos24 = w
                            w = (w + 1)
                            bgra.b[pos24] = (v3 & 255)
                            pos25 = w
                            w = (w + 1)
                            bgra.b[pos25] = (v3 & 255)
                            pos26 = w
                            w = (w + 1)
                            bgra.b[pos26] = (v3 & 255)
                            pos27 = w
                            w = (w + 1)
                            pos28 = r
                            r = (r + 1)
                            v4 = (data.b[pos28] + bgra.b[(w - stride)])
                            bgra.b[pos27] = (v4 & 255)
                    else:
                        _g9 = 0
                        while (_g9 < width):
                            _g9 = (_g9 + 1)
                            pos29 = r
                            r = (r + 1)
                            v5 = (data.b[pos29] + bgra.b[(w - stride)])
                            pos30 = w
                            w = (w + 1)
                            bgra.b[pos30] = (v5 & 255)
                            pos31 = w
                            w = (w + 1)
                            bgra.b[pos31] = (v5 & 255)
                            pos32 = w
                            w = (w + 1)
                            bgra.b[pos32] = (v5 & 255)
                            pos33 = w
                            w = (w + 1)
                            bgra.b[pos33] = (((0 if ((v5 == alphvaIdx)) else 255)) & 255)
                elif (f == 3):
                    cv1 = 0
                    ca1 = 0
                    stride1 = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if _g1:
                        _g10 = 0
                        while (_g10 < width):
                            _g10 = (_g10 + 1)
                            pos34 = r
                            r = (r + 1)
                            cv1 = ((data.b[pos34] + (((cv1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos35 = w
                            w = (w + 1)
                            bgra.b[pos35] = (cv1 & 255)
                            pos36 = w
                            w = (w + 1)
                            bgra.b[pos36] = (cv1 & 255)
                            pos37 = w
                            w = (w + 1)
                            bgra.b[pos37] = (cv1 & 255)
                            pos38 = r
                            r = (r + 1)
                            ca1 = ((data.b[pos38] + (((ca1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos39 = w
                            w = (w + 1)
                            bgra.b[pos39] = (ca1 & 255)
                    else:
                        _g11 = 0
                        while (_g11 < width):
                            _g11 = (_g11 + 1)
                            pos40 = r
                            r = (r + 1)
                            cv1 = ((data.b[pos40] + (((cv1 + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos41 = w
                            w = (w + 1)
                            bgra.b[pos41] = (cv1 & 255)
                            pos42 = w
                            w = (w + 1)
                            bgra.b[pos42] = (cv1 & 255)
                            pos43 = w
                            w = (w + 1)
                            bgra.b[pos43] = (cv1 & 255)
                            pos44 = w
                            w = (w + 1)
                            bgra.b[pos44] = (((0 if ((cv1 == alphvaIdx)) else 255)) & 255)
                elif (f == 4):
                    stride2 = ((width * 4) * flipY1)
                    cv2 = 0
                    ca2 = 0
                    if _g1:
                        _g12 = 0
                        while (_g12 < width):
                            x = _g12
                            _g12 = (_g12 + 1)
                            b = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c = (0 if (((x == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k = ((cv2 + b) - c)
                            pa = (k - cv2)
                            if (pa < 0):
                                pa = -pa
                            pb = (k - b)
                            if (pb < 0):
                                pb = -pb
                            pc = (k - c)
                            if (pc < 0):
                                pc = -pc
                            pos45 = r
                            r = (r + 1)
                            cv2 = ((((cv2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[pos45]) & 255)
                            pos46 = w
                            w = (w + 1)
                            bgra.b[pos46] = (cv2 & 255)
                            pos47 = w
                            w = (w + 1)
                            bgra.b[pos47] = (cv2 & 255)
                            pos48 = w
                            w = (w + 1)
                            bgra.b[pos48] = (cv2 & 255)
                            b1 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c1 = (0 if (((x == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k1 = ((ca2 + b1) - c1)
                            pa1 = (k1 - ca2)
                            if (pa1 < 0):
                                pa1 = -pa1
                            pb1 = (k1 - b1)
                            if (pb1 < 0):
                                pb1 = -pb1
                            pc1 = (k1 - c1)
                            if (pc1 < 0):
                                pc1 = -pc1
                            pos49 = r
                            r = (r + 1)
                            ca2 = ((((ca2 if (((pa1 <= pb1) and ((pa1 <= pc1)))) else (b1 if ((pb1 <= pc1)) else c1))) + data.b[pos49]) & 255)
                            pos50 = w
                            w = (w + 1)
                            bgra.b[pos50] = (ca2 & 255)
                    else:
                        _g13 = 0
                        while (_g13 < width):
                            x1 = _g13
                            _g13 = (_g13 + 1)
                            b2 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c2 = (0 if (((x1 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k2 = ((cv2 + b2) - c2)
                            pa2 = (k2 - cv2)
                            if (pa2 < 0):
                                pa2 = -pa2
                            pb2 = (k2 - b2)
                            if (pb2 < 0):
                                pb2 = -pb2
                            pc2 = (k2 - c2)
                            if (pc2 < 0):
                                pc2 = -pc2
                            pos51 = r
                            r = (r + 1)
                            cv2 = ((((cv2 if (((pa2 <= pb2) and ((pa2 <= pc2)))) else (b2 if ((pb2 <= pc2)) else c2))) + data.b[pos51]) & 255)
                            pos52 = w
                            w = (w + 1)
                            bgra.b[pos52] = (cv2 & 255)
                            pos53 = w
                            w = (w + 1)
                            bgra.b[pos53] = (cv2 & 255)
                            pos54 = w
                            w = (w + 1)
                            bgra.b[pos54] = (cv2 & 255)
                            pos55 = w
                            w = (w + 1)
                            bgra.b[pos55] = (((0 if ((cv2 == alphvaIdx)) else 255)) & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
                w = (w + lineDelta)
        elif (tmp == 1):
            _g1 = _g.params[0]
            if (h.colbits != 8):
                raise haxe_Exception.thrown("Unsupported color mode")
            width = h.width
            if (data.length < ((h.height * (((((4 if _g1 else 3)) * width) + 1))))):
                raise haxe_Exception.thrown("Not enough data")
            alphaRed = -1
            alphaGreen = -1
            alphaBlue = -1
            if (not _g1):
                _g1_head = d.h
                while (_g1_head is not None):
                    val = _g1_head.item
                    _g1_head = _g1_head.next
                    if (val.index == 4):
                        _g = val.params[1]
                        if (val.params[0] == "tRNS"):
                            if (_g.length >= 6):
                                alphaRed = _g.b[1]
                                alphaGreen = _g.b[3]
                                alphaBlue = _g.b[5]
                            break
            cr = 0
            cg = 0
            cb = 0
            ca = 0
            _g = 0
            _g2 = h.height
            while (_g < _g2):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                if (f == 0):
                    if _g1:
                        _g3 = 0
                        while (_g3 < width):
                            _g3 = (_g3 + 1)
                            pos1 = w
                            w = (w + 1)
                            v = data.b[(r + 2)]
                            bgra.b[pos1] = (v & 255)
                            pos2 = w
                            w = (w + 1)
                            v1 = data.b[(r + 1)]
                            bgra.b[pos2] = (v1 & 255)
                            pos3 = w
                            w = (w + 1)
                            v2 = data.b[r]
                            bgra.b[pos3] = (v2 & 255)
                            pos4 = w
                            w = (w + 1)
                            v3 = data.b[(r + 3)]
                            bgra.b[pos4] = (v3 & 255)
                            r = (r + 4)
                    else:
                        _g4 = 0
                        while (_g4 < width):
                            _g4 = (_g4 + 1)
                            pos5 = w
                            w = (w + 1)
                            cb = data.b[(r + 2)]
                            bgra.b[pos5] = (cb & 255)
                            pos6 = w
                            w = (w + 1)
                            cg = data.b[(r + 1)]
                            bgra.b[pos6] = (cg & 255)
                            pos7 = w
                            w = (w + 1)
                            cr = data.b[r]
                            bgra.b[pos7] = (cr & 255)
                            pos8 = w
                            w = (w + 1)
                            bgra.b[pos8] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f == 1):
                    ca = 0
                    cb = 0
                    cg = 0
                    cr = 0
                    if _g1:
                        _g5 = 0
                        while (_g5 < width):
                            _g5 = (_g5 + 1)
                            cb = (cb + data.b[(r + 2)])
                            pos9 = w
                            w = (w + 1)
                            bgra.b[pos9] = (cb & 255)
                            cg = (cg + data.b[(r + 1)])
                            pos10 = w
                            w = (w + 1)
                            bgra.b[pos10] = (cg & 255)
                            cr = (cr + data.b[r])
                            pos11 = w
                            w = (w + 1)
                            bgra.b[pos11] = (cr & 255)
                            ca = (ca + data.b[(r + 3)])
                            pos12 = w
                            w = (w + 1)
                            bgra.b[pos12] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g6 = 0
                        while (_g6 < width):
                            _g6 = (_g6 + 1)
                            cb = (cb + data.b[(r + 2)])
                            pos13 = w
                            w = (w + 1)
                            bgra.b[pos13] = (cb & 255)
                            cg = (cg + data.b[(r + 1)])
                            pos14 = w
                            w = (w + 1)
                            bgra.b[pos14] = (cg & 255)
                            cr = (cr + data.b[r])
                            pos15 = w
                            w = (w + 1)
                            bgra.b[pos15] = (cr & 255)
                            pos16 = w
                            w = (w + 1)
                            bgra.b[pos16] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f == 2):
                    stride = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if _g1:
                        _g7 = 0
                        while (_g7 < width):
                            _g7 = (_g7 + 1)
                            v4 = (data.b[(r + 2)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v4 & 255)
                            w = (w + 1)
                            v5 = (data.b[(r + 1)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v5 & 255)
                            w = (w + 1)
                            v6 = (data.b[r] + bgra.b[(w - stride)])
                            bgra.b[w] = (v6 & 255)
                            w = (w + 1)
                            v7 = (data.b[(r + 3)] + bgra.b[(w - stride)])
                            bgra.b[w] = (v7 & 255)
                            w = (w + 1)
                            r = (r + 4)
                    else:
                        _g8 = 0
                        while (_g8 < width):
                            _g8 = (_g8 + 1)
                            cb = (data.b[(r + 2)] + bgra.b[(w - stride)])
                            bgra.b[w] = (cb & 255)
                            w = (w + 1)
                            cg = (data.b[(r + 1)] + bgra.b[(w - stride)])
                            bgra.b[w] = (cg & 255)
                            w = (w + 1)
                            cr = (data.b[r] + bgra.b[(w - stride)])
                            bgra.b[w] = (cr & 255)
                            w = (w + 1)
                            pos17 = w
                            w = (w + 1)
                            bgra.b[pos17] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f == 3):
                    ca = 0
                    cb = 0
                    cg = 0
                    cr = 0
                    stride1 = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if _g1:
                        _g9 = 0
                        while (_g9 < width):
                            _g9 = (_g9 + 1)
                            cb = ((data.b[(r + 2)] + (((cb + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos18 = w
                            w = (w + 1)
                            bgra.b[pos18] = (cb & 255)
                            cg = ((data.b[(r + 1)] + (((cg + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos19 = w
                            w = (w + 1)
                            bgra.b[pos19] = (cg & 255)
                            cr = ((data.b[r] + (((cr + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos20 = w
                            w = (w + 1)
                            bgra.b[pos20] = (cr & 255)
                            ca = ((data.b[(r + 3)] + (((ca + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos21 = w
                            w = (w + 1)
                            bgra.b[pos21] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g10 = 0
                        while (_g10 < width):
                            _g10 = (_g10 + 1)
                            cb = ((data.b[(r + 2)] + (((cb + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos22 = w
                            w = (w + 1)
                            bgra.b[pos22] = (cb & 255)
                            cg = ((data.b[(r + 1)] + (((cg + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos23 = w
                            w = (w + 1)
                            bgra.b[pos23] = (cg & 255)
                            cr = ((data.b[r] + (((cr + bgra.b[(w - stride1)]) >> 1))) & 255)
                            pos24 = w
                            w = (w + 1)
                            bgra.b[pos24] = (cr & 255)
                            pos25 = w
                            w = (w + 1)
                            bgra.b[pos25] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f == 4):
                    stride2 = ((width * 4) * flipY1)
                    ca = 0
                    cb = 0
                    cg = 0
                    cr = 0
                    if _g1:
                        _g11 = 0
                        while (_g11 < width):
                            x = _g11
                            _g11 = (_g11 + 1)
                            b = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c = (0 if (((x == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k = ((cb + b) - c)
                            pa = (k - cb)
                            if (pa < 0):
                                pa = -pa
                            pb = (k - b)
                            if (pb < 0):
                                pb = -pb
                            pc = (k - c)
                            if (pc < 0):
                                pc = -pc
                            cb = ((((cb if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c))) + data.b[(r + 2)]) & 255)
                            pos26 = w
                            w = (w + 1)
                            bgra.b[pos26] = (cb & 255)
                            b1 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c1 = (0 if (((x == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k1 = ((cg + b1) - c1)
                            pa1 = (k1 - cg)
                            if (pa1 < 0):
                                pa1 = -pa1
                            pb1 = (k1 - b1)
                            if (pb1 < 0):
                                pb1 = -pb1
                            pc1 = (k1 - c1)
                            if (pc1 < 0):
                                pc1 = -pc1
                            cg = ((((cg if (((pa1 <= pb1) and ((pa1 <= pc1)))) else (b1 if ((pb1 <= pc1)) else c1))) + data.b[(r + 1)]) & 255)
                            pos27 = w
                            w = (w + 1)
                            bgra.b[pos27] = (cg & 255)
                            b2 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c2 = (0 if (((x == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k2 = ((cr + b2) - c2)
                            pa2 = (k2 - cr)
                            if (pa2 < 0):
                                pa2 = -pa2
                            pb2 = (k2 - b2)
                            if (pb2 < 0):
                                pb2 = -pb2
                            pc2 = (k2 - c2)
                            if (pc2 < 0):
                                pc2 = -pc2
                            cr = ((((cr if (((pa2 <= pb2) and ((pa2 <= pc2)))) else (b2 if ((pb2 <= pc2)) else c2))) + data.b[r]) & 255)
                            pos28 = w
                            w = (w + 1)
                            bgra.b[pos28] = (cr & 255)
                            b3 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c3 = (0 if (((x == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k3 = ((ca + b3) - c3)
                            pa3 = (k3 - ca)
                            if (pa3 < 0):
                                pa3 = -pa3
                            pb3 = (k3 - b3)
                            if (pb3 < 0):
                                pb3 = -pb3
                            pc3 = (k3 - c3)
                            if (pc3 < 0):
                                pc3 = -pc3
                            ca = ((((ca if (((pa3 <= pb3) and ((pa3 <= pc3)))) else (b3 if ((pb3 <= pc3)) else c3))) + data.b[(r + 3)]) & 255)
                            pos29 = w
                            w = (w + 1)
                            bgra.b[pos29] = (ca & 255)
                            r = (r + 4)
                    else:
                        _g12 = 0
                        while (_g12 < width):
                            x1 = _g12
                            _g12 = (_g12 + 1)
                            b4 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c4 = (0 if (((x1 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k4 = ((cb + b4) - c4)
                            pa4 = (k4 - cb)
                            if (pa4 < 0):
                                pa4 = -pa4
                            pb4 = (k4 - b4)
                            if (pb4 < 0):
                                pb4 = -pb4
                            pc4 = (k4 - c4)
                            if (pc4 < 0):
                                pc4 = -pc4
                            cb = ((((cb if (((pa4 <= pb4) and ((pa4 <= pc4)))) else (b4 if ((pb4 <= pc4)) else c4))) + data.b[(r + 2)]) & 255)
                            pos30 = w
                            w = (w + 1)
                            bgra.b[pos30] = (cb & 255)
                            b5 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c5 = (0 if (((x1 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k5 = ((cg + b5) - c5)
                            pa5 = (k5 - cg)
                            if (pa5 < 0):
                                pa5 = -pa5
                            pb5 = (k5 - b5)
                            if (pb5 < 0):
                                pb5 = -pb5
                            pc5 = (k5 - c5)
                            if (pc5 < 0):
                                pc5 = -pc5
                            cg = ((((cg if (((pa5 <= pb5) and ((pa5 <= pc5)))) else (b5 if ((pb5 <= pc5)) else c5))) + data.b[(r + 1)]) & 255)
                            pos31 = w
                            w = (w + 1)
                            bgra.b[pos31] = (cg & 255)
                            b6 = (0 if ((y == 0)) else bgra.b[(w - stride2)])
                            c6 = (0 if (((x1 == 0) or ((y == 0)))) else bgra.b[((w - stride2) - 4)])
                            k6 = ((cr + b6) - c6)
                            pa6 = (k6 - cr)
                            if (pa6 < 0):
                                pa6 = -pa6
                            pb6 = (k6 - b6)
                            if (pb6 < 0):
                                pb6 = -pb6
                            pc6 = (k6 - c6)
                            if (pc6 < 0):
                                pc6 = -pc6
                            cr = ((((cr if (((pa6 <= pb6) and ((pa6 <= pc6)))) else (b6 if ((pb6 <= pc6)) else c6))) + data.b[r]) & 255)
                            pos32 = w
                            w = (w + 1)
                            bgra.b[pos32] = (cr & 255)
                            pos33 = w
                            w = (w + 1)
                            bgra.b[pos33] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
                w = (w + lineDelta)
        elif (tmp == 2):
            pal = format_png_Tools.getPalette(d)
            if (pal is None):
                raise haxe_Exception.thrown("PNG Palette is missing")
            alpha = None
            _g1_head = d.h
            while (_g1_head is not None):
                val = _g1_head.item
                _g1_head = _g1_head.next
                if (val.index == 4):
                    if (val.params[0] == "tRNS"):
                        alpha = val.params[1]
                        break
            if ((alpha is not None) and ((alpha.length < ((1 << h.colbits))))):
                alpha2 = haxe_io_Bytes.alloc((1 << h.colbits))
                alpha2.blit(0,alpha,0,alpha.length)
                alpha2.fill(alpha.length,(alpha2.length - alpha.length),255)
                alpha = alpha2
            width = h.width
            stride = (Math.ceil(((width * h.colbits) / 8)) + 1)
            if (data.length < ((h.height * stride))):
                raise haxe_Exception.thrown("Not enough data")
            rline = ((h.width * h.colbits) >> 3)
            _g = 0
            _g1 = h.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                if (f == 0):
                    r = (r + rline)
                    continue
                if (f == 1):
                    c = 0
                    _g2 = 0
                    while (_g2 < width):
                        _g2 = (_g2 + 1)
                        c = (c + data.b[r])
                        pos1 = r
                        r = (r + 1)
                        data.b[pos1] = ((c & 255) & 255)
                elif (f == 2):
                    stride = (0 if ((y == 0)) else (rline + 1))
                    _g3 = 0
                    while (_g3 < width):
                        _g3 = (_g3 + 1)
                        v = (data.b[r] + data.b[(r - stride)])
                        data.b[r] = (v & 255)
                        r = (r + 1)
                elif (f == 3):
                    c1 = 0
                    stride1 = (0 if ((y == 0)) else (rline + 1))
                    _g4 = 0
                    while (_g4 < width):
                        _g4 = (_g4 + 1)
                        c1 = ((data.b[r] + (((c1 + data.b[(r - stride1)]) >> 1))) & 255)
                        pos2 = r
                        r = (r + 1)
                        data.b[pos2] = (c1 & 255)
                elif (f == 4):
                    stride2 = (rline + 1)
                    c2 = 0
                    _g5 = 0
                    while (_g5 < width):
                        x = _g5
                        _g5 = (_g5 + 1)
                        v1 = data.b[r]
                        b = (0 if ((y == 0)) else data.b[(r - stride2)])
                        c3 = (0 if (((x == 0) or ((y == 0)))) else data.b[((r - stride2) - 1)])
                        k = ((c2 + b) - c3)
                        pa = (k - c2)
                        if (pa < 0):
                            pa = -pa
                        pb = (k - b)
                        if (pb < 0):
                            pb = -pb
                        pc = (k - c3)
                        if (pc < 0):
                            pc = -pc
                        c2 = ((((c2 if (((pa <= pb) and ((pa <= pc)))) else (b if ((pb <= pc)) else c3))) + v1) & 255)
                        pos3 = r
                        r = (r + 1)
                        data.b[pos3] = (c2 & 255)
                else:
                    raise haxe_Exception.thrown(("Invalid filter " + Std.string(f)))
            r = 0
            if (h.colbits == 8):
                _g = 0
                _g1 = h.height
                while (_g < _g1):
                    _g = (_g + 1)
                    r = (r + 1)
                    _g2 = 0
                    _g3 = h.width
                    while (_g2 < _g3):
                        _g2 = (_g2 + 1)
                        pos = r
                        r = (r + 1)
                        c = data.b[pos]
                        pos1 = w
                        w = (w + 1)
                        v = pal.b[((c * 3) + 2)]
                        bgra.b[pos1] = (v & 255)
                        pos2 = w
                        w = (w + 1)
                        v1 = pal.b[((c * 3) + 1)]
                        bgra.b[pos2] = (v1 & 255)
                        pos3 = w
                        w = (w + 1)
                        v2 = pal.b[(c * 3)]
                        bgra.b[pos3] = (v2 & 255)
                        pos4 = w
                        w = (w + 1)
                        v3 = (alpha.b[c] if ((alpha is not None)) else 255)
                        bgra.b[pos4] = (v3 & 255)
                    w = (w + lineDelta)
            elif (h.colbits < 8):
                req = h.colbits
                mask = (((1 << req)) - 1)
                _g = 0
                _g1 = h.height
                while (_g < _g1):
                    _g = (_g + 1)
                    r = (r + 1)
                    bits = 0
                    nbits = 0
                    _g2 = 0
                    _g3 = h.width
                    while (_g2 < _g3):
                        _g2 = (_g2 + 1)
                        if (nbits < req):
                            pos = r
                            r = (r + 1)
                            bits = ((bits << 8) | data.b[pos])
                            nbits = (nbits + 8)
                        c = (HxOverrides.rshift(bits, ((nbits - req))) & mask)
                        nbits = (nbits - req)
                        pos1 = w
                        w = (w + 1)
                        v = pal.b[((c * 3) + 2)]
                        bgra.b[pos1] = (v & 255)
                        pos2 = w
                        w = (w + 1)
                        v1 = pal.b[((c * 3) + 1)]
                        bgra.b[pos2] = (v1 & 255)
                        pos3 = w
                        w = (w + 1)
                        v2 = pal.b[(c * 3)]
                        bgra.b[pos3] = (v2 & 255)
                        pos4 = w
                        w = (w + 1)
                        v3 = (alpha.b[c] if ((alpha is not None)) else 255)
                        bgra.b[pos4] = (v3 & 255)
                    w = (w + lineDelta)
            else:
                raise haxe_Exception.thrown((Std.string(h.colbits) + " indexed bits per pixel not supported"))
        else:
            pass
        return bgra

    @staticmethod
    def buildGrey(width,height,data,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc(((width * height) + height))
        w = 0
        r = 0
        _g = 0
        while (_g < height):
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g1 = 0
            while (_g1 < width):
                _g1 = (_g1 + 1)
                pos1 = w
                w = (w + 1)
                pos2 = r
                r = (r + 1)
                v = data.b[pos2]
                rgb.b[pos1] = (v & 255)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColGrey(False), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def buildIndexed(width,height,data,palette,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc(((width * height) + height))
        w = 0
        r = 0
        _g = 0
        while (_g < height):
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g1 = 0
            while (_g1 < width):
                _g1 = (_g1 + 1)
                pos1 = w
                w = (w + 1)
                pos2 = r
                r = (r + 1)
                v = data.b[pos2]
                rgb.b[pos1] = (v & 255)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColIndexed, 'interlaced': False})))
        l.add(format_png_Chunk.CPalette(palette))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def buildRGB(width,height,data,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc((((width * height) * 3) + height))
        w = 0
        r = 0
        _g = 0
        while (_g < height):
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g1 = 0
            while (_g1 < width):
                _g1 = (_g1 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 2)]
                rgb.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 1)]
                rgb.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[r]
                rgb.b[pos3] = (v2 & 255)
                r = (r + 3)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(False), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def build32ARGB(width,height,data,level = None):
        if (level is None):
            level = 9
        rgba = haxe_io_Bytes.alloc((((width * height) * 4) + height))
        w = 0
        r = 0
        _g = 0
        while (_g < height):
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgba.b[pos] = 0
            _g1 = 0
            while (_g1 < width):
                _g1 = (_g1 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 1)]
                rgba.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 2)]
                rgba.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[(r + 3)]
                rgba.b[pos3] = (v2 & 255)
                pos4 = w
                w = (w + 1)
                v3 = data.b[r]
                rgba.b[pos4] = (v3 & 255)
                r = (r + 4)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(True), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def build32BGRA(width,height,data,level = None):
        if (level is None):
            level = 9
        rgba = haxe_io_Bytes.alloc((((width * height) * 4) + height))
        w = 0
        r = 0
        _g = 0
        while (_g < height):
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgba.b[pos] = 0
            _g1 = 0
            while (_g1 < width):
                _g1 = (_g1 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 2)]
                rgba.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 1)]
                rgba.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[r]
                rgba.b[pos3] = (v2 & 255)
                pos4 = w
                w = (w + 1)
                v3 = data.b[(r + 3)]
                rgba.b[pos4] = (v3 & 255)
                r = (r + 4)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(True), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)))
        l.add(format_png_Chunk.CEnd)
        return l


class format_png_Writer:
    _hx_class_name = "format.png.Writer"
    __slots__ = ("o",)
    _hx_fields = ["o"]
    _hx_methods = ["write", "writeChunk"]

    def __init__(self,o):
        self.o = o
        o.set_bigEndian(True)

    def write(self,png):
        self.o.writeByte(137)
        self.o.writeByte(80)
        self.o.writeByte(78)
        self.o.writeByte(71)
        self.o.writeByte(13)
        self.o.writeByte(10)
        self.o.writeByte(26)
        self.o.writeByte(10)
        _g_head = png.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            tmp = val.index
            if (tmp == 0):
                self.writeChunk("IEND",haxe_io_Bytes.alloc(0))
            elif (tmp == 1):
                _g = val.params[0]
                b = haxe_io_BytesOutput()
                b.set_bigEndian(True)
                b.writeInt32(_g.width)
                b.writeInt32(_g.height)
                b.writeByte(_g.colbits)
                _g1 = _g.color
                tmp1 = None
                tmp2 = _g1.index
                if (tmp2 == 0):
                    tmp1 = (4 if (_g1.params[0]) else 0)
                elif (tmp2 == 1):
                    tmp1 = (6 if (_g1.params[0]) else 2)
                elif (tmp2 == 2):
                    tmp1 = 3
                else:
                    pass
                b.writeByte(tmp1)
                b.writeByte(0)
                b.writeByte(0)
                b.writeByte((1 if (_g.interlaced) else 0))
                self.writeChunk("IHDR",b.getBytes())
            elif (tmp == 2):
                self.writeChunk("IDAT",val.params[0])
            elif (tmp == 3):
                self.writeChunk("PLTE",val.params[0])
            elif (tmp == 4):
                self.writeChunk(val.params[0],val.params[1])
            else:
                pass

    def writeChunk(self,id,data):
        self.o.writeInt32(data.length)
        self.o.writeString(id)
        self.o.write(data)
        crc_crc = -1
        tmp = (((-1 ^ HxString.charCodeAt(id,0))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (16777215 ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,1))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,2))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp = (((crc_crc ^ HxString.charCodeAt(id,3))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        _hx_len = data.length
        b = data.b
        _g = 0
        while (_g < _hx_len):
            i = _g
            _g = (_g + 1)
            tmp = (((crc_crc ^ b[i])) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        self.o.writeInt32((crc_crc ^ -1))



class format_tools_Deflate:
    _hx_class_name = "format.tools.Deflate"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(b,level = None):
        if (level is None):
            level = 9
        return haxe_zip_Compress.run(b,level)


class format_tools_Inflate:
    _hx_class_name = "format.tools.Inflate"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(_hx_bytes):
        return haxe_zip_Uncompress.run(_hx_bytes)


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["get", "keys"]


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "get_message", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def get_message(self):
        return str(self)

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e



class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value



class haxe_crypto_Adler32:
    _hx_class_name = "haxe.crypto.Adler32"
    __slots__ = ("a1", "a2")
    _hx_fields = ["a1", "a2"]
    _hx_methods = ["update", "equals"]
    _hx_statics = ["read"]

    def __init__(self):
        self.a1 = 1
        self.a2 = 0

    def update(self,b,pos,_hx_len):
        a1 = self.a1
        a2 = self.a2
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            p = _g
            _g = (_g + 1)
            a1 = HxOverrides.mod(((a1 + b.b[p])), 65521)
            a2 = HxOverrides.mod(((a2 + a1)), 65521)
        self.a1 = a1
        self.a2 = a2

    def equals(self,a):
        if (a.a1 == self.a1):
            return (a.a2 == self.a2)
        else:
            return False

    @staticmethod
    def read(i):
        a = haxe_crypto_Adler32()
        a2a = i.readByte()
        a2b = i.readByte()
        a.a1 = ((i.readByte() << 8) | i.readByte())
        a.a2 = ((a2a << 8) | a2b)
        return a



class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "fill", "sub", "compare", "getString", "toString"]
    _hx_statics = ["alloc", "ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def fill(self,pos,_hx_len,value):
        _g = 0
        while (_g < _hx_len):
            _g = (_g + 1)
            pos1 = pos
            pos = (pos + 1)
            self.b[pos1] = (value & 255)

    def sub(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def compare(self,other):
        b1 = self.b
        b2 = other.b
        _hx_len = (self.length if ((self.length < other.length)) else other.length)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (b1[i] != b2[i]):
                return (b1[i] - b2[i])
        return (self.length - other.length)

    def getString(self,pos,_hx_len,encoding = None):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)



class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode", "decode"]

    @staticmethod
    def encode(_hx_bytes,complement = None):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str

    @staticmethod
    def decode(_hx_str,complement = None):
        if (complement is None):
            complement = True
        if complement:
            while (HxString.charCodeAt(_hx_str,(len(_hx_str) - 1)) == 61):
                _hx_str = HxString.substr(_hx_str,0,-1)
        return haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(_hx_str))


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    __slots__ = ("base", "nbits", "tbl")
    _hx_fields = ["base", "nbits", "tbl"]
    _hx_methods = ["encodeBytes", "initTable", "decodeBytes"]

    def __init__(self,base):
        self.tbl = None
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise haxe_Exception.thrown("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except BaseException as _g:
            None
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos = pout
            pout = (pout + 1)
            v = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos] = (v & 255)
        return out

    def initTable(self):
        tbl = list()
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, i, -1)
        _g = 0
        _g1 = self.base.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, self.base.b[i], i)
        self.tbl = tbl

    def decodeBytes(self,b):
        nbits = self.nbits
        if (self.tbl is None):
            self.initTable()
        tbl = self.tbl
        size = ((b.length * nbits) >> 3)
        out = haxe_io_Bytes.alloc(size)
        buf = 0
        curbits = 0
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < 8):
                curbits = (curbits + nbits)
                buf = (buf << nbits)
                pos = pin
                pin = (pin + 1)
                i = python_internal_ArrayImpl._get(tbl, b.b[pos])
                if (i == -1):
                    raise haxe_Exception.thrown("BaseCode : invalid encoded char")
                buf = (buf | i)
            curbits = (curbits - 8)
            pos1 = pout
            pout = (pout + 1)
            out.b[pos1] = (((buf >> curbits) & 255) & 255)
        return out



class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))



class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1



class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next



class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "remove", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def remove(self,key):
        r = (key in self.h)
        if r:
            del self.h[key]
        return r

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))



class haxe_exceptions_PosException(haxe_Exception):
    _hx_class_name = "haxe.exceptions.PosException"
    __slots__ = ("posInfos",)
    _hx_fields = ["posInfos"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,pos = None):
        self.posInfos = None
        super().__init__(message,previous)
        if (pos is None):
            self.posInfos = _hx_AnonObject({'fileName': "(unknown)", 'lineNumber': 0, 'className': "(unknown)", 'methodName': "(unknown)"})
        else:
            self.posInfos = pos

    def toString(self):
        return ((((((((("" + HxOverrides.stringOrNull(super().toString())) + " in ") + HxOverrides.stringOrNull(self.posInfos.className)) + ".") + HxOverrides.stringOrNull(self.posInfos.methodName)) + " at ") + HxOverrides.stringOrNull(self.posInfos.fileName)) + ":") + Std.string(self.posInfos.lineNumber))



class haxe_exceptions_NotImplementedException(haxe_exceptions_PosException):
    _hx_class_name = "haxe.exceptions.NotImplementedException"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_exceptions_PosException


    def __init__(self,message = None,previous = None,pos = None):
        if (message is None):
            message = "Not implemented"
        super().__init__(message,previous,pos)


class haxe_io_ArrayBufferViewImpl:
    _hx_class_name = "haxe.io.ArrayBufferViewImpl"
    __slots__ = ("bytes", "byteOffset", "byteLength")
    _hx_fields = ["bytes", "byteOffset", "byteLength"]

    def __init__(self,_hx_bytes,pos,length):
        self.bytes = _hx_bytes
        self.byteOffset = pos
        self.byteLength = length



class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        self.b = bytearray()

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes



class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "set_bigEndian", "readFullBytes", "read", "readUInt16", "readInt32", "readString"]

    def readByte(self):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Input.hx", 'lineNumber': 53, 'className': "haxe.io.Input", 'methodName': "readByte"}))

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return (_hx_len - k)

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.readBytes(s,pos,_hx_len)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def read(self,nbytes):
        s = haxe_io_Bytes.alloc(nbytes)
        p = 0
        while (nbytes > 0):
            k = self.readBytes(s,p,nbytes)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            nbytes = (nbytes - k)
        return s

    def readUInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        if self.bigEndian:
            return (ch2 | ((ch1 << 8)))
        else:
            return (ch1 | ((ch2 << 8)))

    def readInt32(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        ch4 = self.readByte()
        n = ((((ch4 | ((ch3 << 8))) | ((ch2 << 16))) | ((ch1 << 24))) if (self.bigEndian) else (((ch1 | ((ch2 << 8))) | ((ch3 << 16))) | ((ch4 << 24))))
        if (((n & -2147483648)) != 0):
            return (n | -2147483648)
        else:
            return n

    def readString(self,_hx_len,encoding = None):
        b = haxe_io_Bytes.alloc(_hx_len)
        self.readFullBytes(b,0,_hx_len)
        return b.getString(0,_hx_len,encoding)



class haxe_io_BytesInput(haxe_io_Input):
    _hx_class_name = "haxe.io.BytesInput"
    __slots__ = ("b", "pos", "len", "totlen")
    _hx_fields = ["b", "pos", "len", "totlen"]
    _hx_methods = ["readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,b,pos = None,_hx_len = None):
        if (pos is None):
            pos = 0
        if (_hx_len is None):
            _hx_len = (b.length - pos)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > b.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        self.b = b.b
        self.pos = pos
        self.len = _hx_len
        self.totlen = _hx_len
        self.set_bigEndian(False)

    def readByte(self):
        if (self.len == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 - 1)
        _hx_local_1
        b = self.b[self.pos]
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.pos
        _hx_local_2.pos = (_hx_local_3 + 1)
        _hx_local_3
        return b

    def readBytes(self,buf,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        if ((self.len == 0) and ((_hx_len > 0))):
            raise haxe_Exception.thrown(haxe_io_Eof())
        if (self.len < _hx_len):
            _hx_len = self.len
        b1 = self.b
        b2 = buf.b
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b2[(pos + i)] = b1[(self.pos + i)]
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.len
        _hx_local_2.len = (_hx_local_3 - _hx_len)
        _hx_local_2.len
        return _hx_len



class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "set_bigEndian", "write", "writeFullBytes", "writeInt32", "writeString"]

    def writeByte(self,c):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Output.hx", 'lineNumber': 47, 'className': "haxe.io.Output", 'methodName': "writeByte"}))

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeInt32(self,x):
        if self.bigEndian:
            self.writeByte(HxOverrides.rshift(x, 24))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(HxOverrides.rshift(x, 24))

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)



class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        _this.b.extend(buf.b[pos:(pos + _hx_len)])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()


class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"


class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()



class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()



class haxe_zip_Compress:
    _hx_class_name = "haxe.zip.Compress"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(s,level):
        raise haxe_exceptions_NotImplementedException("Not implemented for this platform",None,_hx_AnonObject({'fileName': "haxe/zip/Compress.hx", 'lineNumber': 39, 'className': "haxe.zip.Compress", 'methodName': "run"}))

class haxe_zip_Huffman(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip.Huffman"
    _hx_constructs = ["Found", "NeedBit", "NeedBits"]

    @staticmethod
    def Found(i):
        return haxe_zip_Huffman("Found", 0, (i,))

    @staticmethod
    def NeedBit(left,right):
        return haxe_zip_Huffman("NeedBit", 1, (left,right))

    @staticmethod
    def NeedBits(n,table):
        return haxe_zip_Huffman("NeedBits", 2, (n,table))


class haxe_zip_HuffTools:
    _hx_class_name = "haxe.zip.HuffTools"
    __slots__ = ()
    _hx_methods = ["treeDepth", "treeCompress", "treeWalk", "treeMake", "make"]

    def __init__(self):
        pass

    def treeDepth(self,t):
        tmp = t.index
        if (tmp == 0):
            return 0
        elif (tmp == 1):
            da = self.treeDepth(t.params[0])
            db = self.treeDepth(t.params[1])
            return (1 + ((da if ((da < db)) else db)))
        elif (tmp == 2):
            raise haxe_Exception.thrown("assert")
        else:
            pass

    def treeCompress(self,t):
        d = self.treeDepth(t)
        if (d == 0):
            return t
        if (d == 1):
            if (t.index == 1):
                return haxe_zip_Huffman.NeedBit(self.treeCompress(t.params[0]),self.treeCompress(t.params[1]))
            else:
                raise haxe_Exception.thrown("assert")
        size = (1 << d)
        table = list()
        _g = 0
        while (_g < size):
            _g = (_g + 1)
            table.append(haxe_zip_Huffman.Found(-1))
        self.treeWalk(table,0,0,d,t)
        return haxe_zip_Huffman.NeedBits(d,table)

    def treeWalk(self,table,p,cd,d,t):
        if (t.index == 1):
            if (d > 0):
                self.treeWalk(table,p,(cd + 1),(d - 1),t.params[0])
                self.treeWalk(table,(p | ((1 << cd))),(cd + 1),(d - 1),t.params[1])
            else:
                python_internal_ArrayImpl._set(table, p, self.treeCompress(t))
        else:
            python_internal_ArrayImpl._set(table, p, self.treeCompress(t))

    def treeMake(self,bits,maxbits,v,_hx_len):
        if (_hx_len > maxbits):
            raise haxe_Exception.thrown("Invalid huffman")
        idx = ((v << 5) | _hx_len)
        if (idx in bits.h):
            return haxe_zip_Huffman.Found(bits.h.get(idx,None))
        v = (v << 1)
        _hx_len = (_hx_len + 1)
        return haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,v,_hx_len),self.treeMake(bits,maxbits,(v | 1),_hx_len))

    def make(self,lengths,pos,nlengths,maxbits):
        if (nlengths == 1):
            return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0))
        counts = list()
        tmp = list()
        if (maxbits > 32):
            raise haxe_Exception.thrown("Invalid huffman")
        _g = 0
        while (_g < maxbits):
            _g = (_g + 1)
            counts.append(0)
            tmp.append(0)
        _g = 0
        while (_g < nlengths):
            i = _g
            _g = (_g + 1)
            p = python_internal_ArrayImpl._get(lengths, (i + pos))
            if (p >= maxbits):
                raise haxe_Exception.thrown("Invalid huffman")
            python_internal_ArrayImpl._set(counts, p, ((counts[p] if p >= 0 and p < len(counts) else None) + 1))
        code = 0
        _g = 1
        _g1 = (maxbits - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            code = ((code + (counts[i] if i >= 0 and i < len(counts) else None)) << 1)
            python_internal_ArrayImpl._set(tmp, i, code)
        bits = haxe_ds_IntMap()
        _g = 0
        while (_g < nlengths):
            i = _g
            _g = (_g + 1)
            l = python_internal_ArrayImpl._get(lengths, (i + pos))
            if (l != 0):
                n = python_internal_ArrayImpl._get(tmp, (l - 1))
                python_internal_ArrayImpl._set(tmp, (l - 1), (n + 1))
                bits.set(((n << 5) | l),i)
        return self.treeCompress(haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,0,1),self.treeMake(bits,maxbits,1,1)))



class haxe_zip__InflateImpl_Window:
    _hx_class_name = "haxe.zip._InflateImpl.Window"
    __slots__ = ("buffer", "pos", "crc")
    _hx_fields = ["buffer", "pos", "crc"]
    _hx_methods = ["slide", "addBytes", "addByte", "getLastChar", "available", "checksum"]

    def __init__(self,hasCrc):
        self.crc = None
        self.buffer = haxe_io_Bytes.alloc(65536)
        self.pos = 0
        if hasCrc:
            self.crc = haxe_crypto_Adler32()

    def slide(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,32768)
        b = haxe_io_Bytes.alloc(65536)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 - 32768)
        _hx_local_0.pos
        b.blit(0,self.buffer,32768,self.pos)
        self.buffer = b

    def addBytes(self,b,p,_hx_len):
        if ((self.pos + _hx_len) > 65536):
            self.slide()
        self.buffer.blit(self.pos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos

    def addByte(self,c):
        if (self.pos == 65536):
            self.slide()
        self.buffer.b[self.pos] = (c & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def getLastChar(self):
        return self.buffer.b[(self.pos - 1)]

    def available(self):
        return self.pos

    def checksum(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,self.pos)
        return self.crc


class haxe_zip__InflateImpl_State(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip._InflateImpl.State"
    _hx_constructs = ["Head", "Block", "CData", "Flat", "Crc", "Dist", "DistOne", "Done"]
haxe_zip__InflateImpl_State.Head = haxe_zip__InflateImpl_State("Head", 0, ())
haxe_zip__InflateImpl_State.Block = haxe_zip__InflateImpl_State("Block", 1, ())
haxe_zip__InflateImpl_State.CData = haxe_zip__InflateImpl_State("CData", 2, ())
haxe_zip__InflateImpl_State.Flat = haxe_zip__InflateImpl_State("Flat", 3, ())
haxe_zip__InflateImpl_State.Crc = haxe_zip__InflateImpl_State("Crc", 4, ())
haxe_zip__InflateImpl_State.Dist = haxe_zip__InflateImpl_State("Dist", 5, ())
haxe_zip__InflateImpl_State.DistOne = haxe_zip__InflateImpl_State("DistOne", 6, ())
haxe_zip__InflateImpl_State.Done = haxe_zip__InflateImpl_State("Done", 7, ())


class haxe_zip_InflateImpl:
    _hx_class_name = "haxe.zip.InflateImpl"
    __slots__ = ("nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window")
    _hx_fields = ["nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window"]
    _hx_methods = ["buildFixedHuffman", "readBytes", "getBits", "getBit", "getRevBits", "resetBits", "addBytes", "addByte", "addDistOne", "addDist", "applyHuffman", "inflateLengths", "inflateLoop"]
    _hx_statics = ["LEN_EXTRA_BITS_TBL", "LEN_BASE_VAL_TBL", "DIST_EXTRA_BITS_TBL", "DIST_BASE_VAL_TBL", "CODE_LENGTHS_POS", "FIXED_HUFFMAN", "run"]

    def __init__(self,i,header = None,crc = None):
        if (header is None):
            header = True
        if (crc is None):
            crc = True
        self.window = None
        self.lengths = None
        self.input = None
        self.outpos = None
        self.output = None
        self.needed = None
        self.dist = None
        self.len = None
        self.huffdist = None
        self.huffman = None
        self.state = None
        self.bits = None
        self.nbits = None
        self.isFinal = False
        self.htools = haxe_zip_HuffTools()
        self.huffman = self.buildFixedHuffman()
        self.huffdist = None
        self.len = 0
        self.dist = 0
        self.state = (haxe_zip__InflateImpl_State.Head if header else haxe_zip__InflateImpl_State.Block)
        self.input = i
        self.bits = 0
        self.nbits = 0
        self.needed = 0
        self.output = None
        self.outpos = 0
        self.lengths = list()
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.window = haxe_zip__InflateImpl_Window(crc)

    def buildFixedHuffman(self):
        if (haxe_zip_InflateImpl.FIXED_HUFFMAN is not None):
            return haxe_zip_InflateImpl.FIXED_HUFFMAN
        a = list()
        _g = 0
        while (_g < 288):
            n = _g
            _g = (_g + 1)
            a.append((8 if ((n <= 143)) else (9 if ((n <= 255)) else (7 if ((n <= 279)) else 8))))
        haxe_zip_InflateImpl.FIXED_HUFFMAN = self.htools.make(a,0,288,10)
        return haxe_zip_InflateImpl.FIXED_HUFFMAN

    def readBytes(self,b,pos,_hx_len):
        self.needed = _hx_len
        self.outpos = pos
        self.output = b
        if (_hx_len > 0):
            while self.inflateLoop():
                pass
        return (_hx_len - self.needed)

    def getBits(self,n):
        while (self.nbits < n):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.bits
            _hx_local_0.bits = (_hx_local_1 | ((self.input.readByte() << self.nbits)))
            _hx_local_0.bits
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.nbits
            _hx_local_2.nbits = (_hx_local_3 + 8)
            _hx_local_2.nbits
        b = (self.bits & ((((1 << n)) - 1)))
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.nbits
        _hx_local_4.nbits = (_hx_local_5 - n)
        _hx_local_4.nbits
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.bits
        _hx_local_6.bits = (_hx_local_7 >> n)
        _hx_local_6.bits
        return b

    def getBit(self):
        if (self.nbits == 0):
            self.nbits = 8
            self.bits = self.input.readByte()
        b = (((self.bits & 1)) == 1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bits
        _hx_local_2.bits = (_hx_local_3 >> 1)
        _hx_local_2.bits
        return b

    def getRevBits(self,n):
        if (n == 0):
            return 0
        elif self.getBit():
            return ((1 << ((n - 1))) | self.getRevBits((n - 1)))
        else:
            return self.getRevBits((n - 1))

    def resetBits(self):
        self.bits = 0
        self.nbits = 0

    def addBytes(self,b,p,_hx_len):
        self.window.addBytes(b,p,_hx_len)
        self.output.blit(self.outpos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - _hx_len)
        _hx_local_0.needed
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + _hx_len)
        _hx_local_2.outpos

    def addByte(self,b):
        self.window.addByte(b)
        self.output.b[self.outpos] = (b & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + 1)
        _hx_local_3

    def addDistOne(self,n):
        c = self.window.getLastChar()
        _g = 0
        while (_g < n):
            _g = (_g + 1)
            self.addByte(c)

    def addDist(self,d,_hx_len):
        self.addBytes(self.window.buffer,(self.window.pos - d),_hx_len)

    def applyHuffman(self,h):
        tmp = h.index
        if (tmp == 0):
            return h.params[0]
        elif (tmp == 1):
            return self.applyHuffman((h.params[1] if (self.getBit()) else h.params[0]))
        elif (tmp == 2):
            return self.applyHuffman(python_internal_ArrayImpl._get(h.params[1], self.getBits(h.params[0])))
        else:
            pass

    def inflateLengths(self,a,_hx_max):
        i = 0
        prev = 0
        while (i < _hx_max):
            n = self.applyHuffman(self.huffman)
            if ((((((((((((((((n == 15) or ((n == 14))) or ((n == 13))) or ((n == 12))) or ((n == 11))) or ((n == 10))) or ((n == 9))) or ((n == 8))) or ((n == 7))) or ((n == 6))) or ((n == 5))) or ((n == 4))) or ((n == 3))) or ((n == 2))) or ((n == 1))) or ((n == 0))):
                prev = n
                python_internal_ArrayImpl._set(a, i, n)
                i = (i + 1)
            elif (n == 16):
                end = ((i + 3) + self.getBits(2))
                if (end > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
                while (i < end):
                    python_internal_ArrayImpl._set(a, i, prev)
                    i = (i + 1)
            elif (n == 17):
                i = (i + ((3 + self.getBits(3))))
                if (i > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
            elif (n == 18):
                i = (i + ((11 + self.getBits(7))))
                if (i > _hx_max):
                    raise haxe_Exception.thrown("Invalid data")
            else:
                raise haxe_Exception.thrown("Invalid data")

    def inflateLoop(self):
        tmp = self.state.index
        if (tmp == 0):
            cmf = self.input.readByte()
            if (((cmf & 15)) != 8):
                raise haxe_Exception.thrown("Invalid data")
            flg = self.input.readByte()
            if (HxOverrides.mod(((((cmf << 8)) + flg)), 31) != 0):
                raise haxe_Exception.thrown("Invalid data")
            if (((flg & 32)) != 0):
                raise haxe_Exception.thrown("Unsupported dictionary")
            self.state = haxe_zip__InflateImpl_State.Block
            return True
        elif (tmp == 1):
            self.isFinal = self.getBit()
            _g = self.getBits(2)
            if (_g == 0):
                self.len = self.input.readUInt16()
                if (self.input.readUInt16() != ((65535 - self.len))):
                    raise haxe_Exception.thrown("Invalid data")
                self.state = haxe_zip__InflateImpl_State.Flat
                r = self.inflateLoop()
                self.resetBits()
                return r
            elif (_g == 1):
                self.huffman = self.buildFixedHuffman()
                self.huffdist = None
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            elif (_g == 2):
                hlit = (self.getBits(5) + 257)
                hdist = (self.getBits(5) + 1)
                hclen = (self.getBits(4) + 4)
                _g = 0
                while (_g < hclen):
                    i = _g
                    _g = (_g + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i), self.getBits(3))
                _g = hclen
                while (_g < 19):
                    i = _g
                    _g = (_g + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i), 0)
                self.huffman = self.htools.make(self.lengths,0,19,8)
                lengths = list()
                _g = 0
                _g1 = (hlit + hdist)
                while (_g < _g1):
                    _g = (_g + 1)
                    lengths.append(0)
                self.inflateLengths(lengths,(hlit + hdist))
                self.huffdist = self.htools.make(lengths,hlit,hdist,16)
                self.huffman = self.htools.make(lengths,0,hlit,16)
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            else:
                raise haxe_Exception.thrown("Invalid data")
        elif (tmp == 2):
            n = self.applyHuffman(self.huffman)
            if (n < 256):
                self.addByte(n)
                return (self.needed > 0)
            elif (n == 256):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
                return True
            else:
                n = (n - 257)
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL, n)
                if (extra_bits == -1):
                    raise haxe_Exception.thrown("Invalid data")
                self.len = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_BASE_VAL_TBL, n) + self.getBits(extra_bits))
                dist_code = (self.getRevBits(5) if ((self.huffdist is None)) else self.applyHuffman(self.huffdist))
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL, dist_code)
                if (extra_bits == -1):
                    raise haxe_Exception.thrown("Invalid data")
                self.dist = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_BASE_VAL_TBL, dist_code) + self.getBits(extra_bits))
                if (self.dist > self.window.available()):
                    raise haxe_Exception.thrown("Invalid data")
                self.state = (haxe_zip__InflateImpl_State.DistOne if ((self.dist == 1)) else haxe_zip__InflateImpl_State.Dist)
                return True
        elif (tmp == 3):
            rlen = (self.len if ((self.len < self.needed)) else self.needed)
            _hx_bytes = self.input.read(rlen)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.len
            _hx_local_2.len = (_hx_local_3 - rlen)
            _hx_local_2.len
            self.addBytes(_hx_bytes,0,rlen)
            if (self.len == 0):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
            return (self.needed > 0)
        elif (tmp == 4):
            calc = self.window.checksum()
            if (calc is None):
                self.state = haxe_zip__InflateImpl_State.Done
                return True
            if (not calc.equals(haxe_crypto_Adler32.read(self.input))):
                raise haxe_Exception.thrown("Invalid CRC")
            self.state = haxe_zip__InflateImpl_State.Done
            return True
        elif (tmp == 5):
            while ((self.len > 0) and ((self.needed > 0))):
                rdist = (self.len if ((self.len < self.dist)) else self.dist)
                rlen = (self.needed if ((self.needed < rdist)) else rdist)
                self.addDist(self.dist,rlen)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.len
                _hx_local_4.len = (_hx_local_5 - rlen)
                _hx_local_4.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 6):
            rlen = (self.len if ((self.len < self.needed)) else self.needed)
            self.addDistOne(rlen)
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.len
            _hx_local_6.len = (_hx_local_7 - rlen)
            _hx_local_6.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 7):
            return False
        else:
            pass

    @staticmethod
    def run(i,bufsize = None):
        if (bufsize is None):
            bufsize = 65536
        buf = haxe_io_Bytes.alloc(bufsize)
        output = haxe_io_BytesBuffer()
        inflate = haxe_zip_InflateImpl(i)
        while True:
            _hx_len = inflate.readBytes(buf,0,bufsize)
            if ((_hx_len < 0) or ((_hx_len > buf.length))):
                raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
            output.b.extend(buf.b[0:_hx_len])
            if (_hx_len < bufsize):
                break
        return output.getBytes()



class haxe_zip_Uncompress:
    _hx_class_name = "haxe.zip.Uncompress"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(src,bufsize = None):
        return haxe_zip_InflateImpl.run(haxe_io_BytesInput(src),bufsize)


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            _hx_local_0 = len(field)
            if (_hx_local_0 == 10):
                if (field == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field == "length"):
                    return len(o)
                elif (field == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            _hx_local_1 = len(field)
            if (_hx_local_1 == 11):
                if (field == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field == "length"):
                    return len(o)
                elif (field == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has



class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["printString"]

    @staticmethod
    def printString(_hx_str):
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        while (_g < _hx_len):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "rshift", "modf", "mod"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)



class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def close(self):
        self.stream.close()



class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte", "writeBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.write(s.b[pos:(pos + _hx_len)])



class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "close", "write", "writeFullBytes", "writeInt32", "writeString"]


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeBytes", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.buffer.write(s.b[pos:(pos + _hx_len)])

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))



class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileOutputFromText", "createFileOutputFromBytes"]

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["write"]

    @staticmethod
    def write(path,binary = None):
        if (binary is None):
            binary = True
        f = python_lib_Builtins.open(path,("wb" if binary else "w"),-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "close", "write", "writeFullBytes", "writeInt32", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def close(self):
        self.impl.close()

    def write(self,s):
        self.impl.write(s)

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeInt32(self,x):
        self.impl.writeInt32(x)

    def writeString(self,s,encoding = None):
        self.impl.writeString(s)


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

bitmap_support_Pako.js = "\n/* pako 1.0.4 nodeca/pako */\n!function(t){(typeof global==='undefined' ? window : global).pako=t()}(function(){return function t(e,a,i){function n(s,o){if(!a[s]){if(!e[s]){var l=\"function\"==typeof require&&require;if(!o&&l)return l(s,!0);if(r)return r(s,!0);var h=new Error(\"Cannot find module '\"+s+\"'\");throw h.code=\"MODULE_NOT_FOUND\",h}var d=a[s]={exports:{}};e[s][0].call(d.exports,function(t){var a=e[s][1][t];return n(a?a:t)},d,d.exports,t,e,a,i)}return a[s].exports}for(var r=\"function\"==typeof require&&require,s=0;s<i.length;s++)n(i[s]);return n}({1:[function(t,e,a){\"use strict\";function i(t){if(!(this instanceof i))return new i(t);this.options=l.assign({level:w,method:v,chunkSize:16384,windowBits:15,memLevel:8,strategy:p,to:\"\"},t||{});var e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new f,this.strm.avail_out=0;var a=o.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(a!==b)throw new Error(d[a]);if(e.header&&o.deflateSetHeader(this.strm,e.header),e.dictionary){var n;if(n=\"string\"==typeof e.dictionary?h.string2buf(e.dictionary):\"[object ArrayBuffer]\"===_.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,a=o.deflateSetDictionary(this.strm,n),a!==b)throw new Error(d[a]);this._dict_set=!0}}function n(t,e){var a=new i(e);if(a.push(t,!0),a.err)throw a.msg||d[a.err];return a.result}function r(t,e){return e=e||{},e.raw=!0,n(t,e)}function s(t,e){return e=e||{},e.gzip=!0,n(t,e)}var o=t(\"./zlib/deflate\"),l=t(\"./utils/common\"),h=t(\"./utils/strings\"),d=t(\"./zlib/messages\"),f=t(\"./zlib/zstream\"),_=Object.prototype.toString,u=0,c=4,b=0,g=1,m=2,w=-1,p=0,v=8;i.prototype.push=function(t,e){var a,i,n=this.strm,r=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:e===!0?c:u,\"string\"==typeof t?n.input=h.string2buf(t):\"[object ArrayBuffer]\"===_.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new l.Buf8(r),n.next_out=0,n.avail_out=r),a=o.deflate(n,i),a!==g&&a!==b)return this.onEnd(a),this.ended=!0,!1;0!==n.avail_out&&(0!==n.avail_in||i!==c&&i!==m)||(\"string\"===this.options.to?this.onData(h.buf2binstring(l.shrinkBuf(n.output,n.next_out))):this.onData(l.shrinkBuf(n.output,n.next_out)))}while((n.avail_in>0||0===n.avail_out)&&a!==g);return i===c?(a=o.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===b):i!==m||(this.onEnd(b),n.avail_out=0,!0)},i.prototype.onData=function(t){this.chunks.push(t)},i.prototype.onEnd=function(t){t===b&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=l.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},a.Deflate=i,a.deflate=n,a.deflateRaw=r,a.gzip=s},{\"./utils/common\":3,\"./utils/strings\":4,\"./zlib/deflate\":8,\"./zlib/messages\":13,\"./zlib/zstream\":15}],2:[function(t,e,a){\"use strict\";function i(t){if(!(this instanceof i))return new i(t);this.options=o.assign({chunkSize:16384,windowBits:0,to:\"\"},t||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0===(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new f,this.strm.avail_out=0;var a=s.inflateInit2(this.strm,e.windowBits);if(a!==h.Z_OK)throw new Error(d[a]);this.header=new _,s.inflateGetHeader(this.strm,this.header)}function n(t,e){var a=new i(e);if(a.push(t,!0),a.err)throw a.msg||d[a.err];return a.result}function r(t,e){return e=e||{},e.raw=!0,n(t,e)}var s=t(\"./zlib/inflate\"),o=t(\"./utils/common\"),l=t(\"./utils/strings\"),h=t(\"./zlib/constants\"),d=t(\"./zlib/messages\"),f=t(\"./zlib/zstream\"),_=t(\"./zlib/gzheader\"),u=Object.prototype.toString;i.prototype.push=function(t,e){var a,i,n,r,d,f,_=this.strm,c=this.options.chunkSize,b=this.options.dictionary,g=!1;if(this.ended)return!1;i=e===~~e?e:e===!0?h.Z_FINISH:h.Z_NO_FLUSH,\"string\"==typeof t?_.input=l.binstring2buf(t):\"[object ArrayBuffer]\"===u.call(t)?_.input=new Uint8Array(t):_.input=t,_.next_in=0,_.avail_in=_.input.length;do{if(0===_.avail_out&&(_.output=new o.Buf8(c),_.next_out=0,_.avail_out=c),a=s.inflate(_,h.Z_NO_FLUSH),a===h.Z_NEED_DICT&&b&&(f=\"string\"==typeof b?l.string2buf(b):\"[object ArrayBuffer]\"===u.call(b)?new Uint8Array(b):b,a=s.inflateSetDictionary(this.strm,f)),a===h.Z_BUF_ERROR&&g===!0&&(a=h.Z_OK,g=!1),a!==h.Z_STREAM_END&&a!==h.Z_OK)return this.onEnd(a),this.ended=!0,!1;_.next_out&&(0!==_.avail_out&&a!==h.Z_STREAM_END&&(0!==_.avail_in||i!==h.Z_FINISH&&i!==h.Z_SYNC_FLUSH)||(\"string\"===this.options.to?(n=l.utf8border(_.output,_.next_out),r=_.next_out-n,d=l.buf2string(_.output,n),_.next_out=r,_.avail_out=c-r,r&&o.arraySet(_.output,_.output,n,r,0),this.onData(d)):this.onData(o.shrinkBuf(_.output,_.next_out)))),0===_.avail_in&&0===_.avail_out&&(g=!0)}while((_.avail_in>0||0===_.avail_out)&&a!==h.Z_STREAM_END);return a===h.Z_STREAM_END&&(i=h.Z_FINISH),i===h.Z_FINISH?(a=s.inflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===h.Z_OK):i!==h.Z_SYNC_FLUSH||(this.onEnd(h.Z_OK),_.avail_out=0,!0)},i.prototype.onData=function(t){this.chunks.push(t)},i.prototype.onEnd=function(t){t===h.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},a.Inflate=i,a.inflate=n,a.inflateRaw=r,a.ungzip=n},{\"./utils/common\":3,\"./utils/strings\":4,\"./zlib/constants\":6,\"./zlib/gzheader\":9,\"./zlib/inflate\":11,\"./zlib/messages\":13,\"./zlib/zstream\":15}],3:[function(t,e,a){\"use strict\";var i=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;a.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var a=e.shift();if(a){if(\"object\"!=typeof a)throw new TypeError(a+\"must be non-object\");for(var i in a)a.hasOwnProperty(i)&&(t[i]=a[i])}}return t},a.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,a,i,n){if(e.subarray&&t.subarray)return void t.set(e.subarray(a,a+i),n);for(var r=0;r<i;r++)t[n+r]=e[a+r]},flattenChunks:function(t){var e,a,i,n,r,s;for(i=0,e=0,a=t.length;e<a;e++)i+=t[e].length;for(s=new Uint8Array(i),n=0,e=0,a=t.length;e<a;e++)r=t[e],s.set(r,n),n+=r.length;return s}},r={arraySet:function(t,e,a,i,n){for(var r=0;r<i;r++)t[n+r]=e[a+r]},flattenChunks:function(t){return[].concat.apply([],t)}};a.setTyped=function(t){t?(a.Buf8=Uint8Array,a.Buf16=Uint16Array,a.Buf32=Int32Array,a.assign(a,n)):(a.Buf8=Array,a.Buf16=Array,a.Buf32=Array,a.assign(a,r))},a.setTyped(i)},{}],4:[function(t,e,a){\"use strict\";function i(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&r))return String.fromCharCode.apply(null,n.shrinkBuf(t,e));for(var a=\"\",i=0;i<e;i++)a+=String.fromCharCode(t[i]);return a}var n=t(\"./common\"),r=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){r=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var o=new n.Buf8(256),l=0;l<256;l++)o[l]=l>=252?6:l>=248?5:l>=240?4:l>=224?3:l>=192?2:1;o[254]=o[254]=1,a.string2buf=function(t){var e,a,i,r,s,o=t.length,l=0;for(r=0;r<o;r++)a=t.charCodeAt(r),55296===(64512&a)&&r+1<o&&(i=t.charCodeAt(r+1),56320===(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),r++)),l+=a<128?1:a<2048?2:a<65536?3:4;for(e=new n.Buf8(l),s=0,r=0;s<l;r++)a=t.charCodeAt(r),55296===(64512&a)&&r+1<o&&(i=t.charCodeAt(r+1),56320===(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),r++)),a<128?e[s++]=a:a<2048?(e[s++]=192|a>>>6,e[s++]=128|63&a):a<65536?(e[s++]=224|a>>>12,e[s++]=128|a>>>6&63,e[s++]=128|63&a):(e[s++]=240|a>>>18,e[s++]=128|a>>>12&63,e[s++]=128|a>>>6&63,e[s++]=128|63&a);return e},a.buf2binstring=function(t){return i(t,t.length)},a.binstring2buf=function(t){for(var e=new n.Buf8(t.length),a=0,i=e.length;a<i;a++)e[a]=t.charCodeAt(a);return e},a.buf2string=function(t,e){var a,n,r,s,l=e||t.length,h=new Array(2*l);for(n=0,a=0;a<l;)if(r=t[a++],r<128)h[n++]=r;else if(s=o[r],s>4)h[n++]=65533,a+=s-1;else{for(r&=2===s?31:3===s?15:7;s>1&&a<l;)r=r<<6|63&t[a++],s--;s>1?h[n++]=65533:r<65536?h[n++]=r:(r-=65536,h[n++]=55296|r>>10&1023,h[n++]=56320|1023&r)}return i(h,n)},a.utf8border=function(t,e){var a;for(e=e||t.length,e>t.length&&(e=t.length),a=e-1;a>=0&&128===(192&t[a]);)a--;return a<0?e:0===a?e:a+o[t[a]]>e?a:e}},{\"./common\":3}],5:[function(t,e,a){\"use strict\";function i(t,e,a,i){for(var n=65535&t|0,r=t>>>16&65535|0,s=0;0!==a;){s=a>2e3?2e3:a,a-=s;do n=n+e[i++]|0,r=r+n|0;while(--s);n%=65521,r%=65521}return n|r<<16|0}e.exports=i},{}],6:[function(t,e,a){\"use strict\";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],7:[function(t,e,a){\"use strict\";function i(){for(var t,e=[],a=0;a<256;a++){t=a;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}function n(t,e,a,i){var n=r,s=i+a;t^=-1;for(var o=i;o<s;o++)t=t>>>8^n[255&(t^e[o])];return t^-1}var r=i();e.exports=n},{}],8:[function(t,e,a){\"use strict\";function i(t,e){return t.msg=D[e],e}function n(t){return(t<<1)-(t>4?9:0)}function r(t){for(var e=t.length;--e>=0;)t[e]=0}function s(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(R.arraySet(t.output,e.pending_buf,e.pending_out,a,t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))}function o(t,e){C._tr_flush_block(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,s(t.strm)}function l(t,e){t.pending_buf[t.pending++]=e}function h(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function d(t,e,a,i){var n=t.avail_in;return n>i&&(n=i),0===n?0:(t.avail_in-=n,R.arraySet(e,t.input,t.next_in,n,a),1===t.state.wrap?t.adler=N(t.adler,e,n,a):2===t.state.wrap&&(t.adler=O(t.adler,e,n,a)),t.next_in+=n,t.total_in+=n,n)}function f(t,e){var a,i,n=t.max_chain_length,r=t.strstart,s=t.prev_length,o=t.nice_match,l=t.strstart>t.w_size-ft?t.strstart-(t.w_size-ft):0,h=t.window,d=t.w_mask,f=t.prev,_=t.strstart+dt,u=h[r+s-1],c=h[r+s];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do if(a=e,h[a+s]===c&&h[a+s-1]===u&&h[a]===h[r]&&h[++a]===h[r+1]){r+=2,a++;do;while(h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&r<_);if(i=dt-(_-r),r=_-dt,i>s){if(t.match_start=e,s=i,i>=o)break;u=h[r+s-1],c=h[r+s]}}while((e=f[e&d])>l&&0!==--n);return s<=t.lookahead?s:t.lookahead}function _(t){var e,a,i,n,r,s=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=s+(s-ft)){R.arraySet(t.window,t.window,s,s,0),t.match_start-=s,t.strstart-=s,t.block_start-=s,a=t.hash_size,e=a;do i=t.head[--e],t.head[e]=i>=s?i-s:0;while(--a);a=s,e=a;do i=t.prev[--e],t.prev[e]=i>=s?i-s:0;while(--a);n+=s}if(0===t.strm.avail_in)break;if(a=d(t.strm,t.window,t.strstart+t.lookahead,n),t.lookahead+=a,t.lookahead+t.insert>=ht)for(r=t.strstart-t.insert,t.ins_h=t.window[r],t.ins_h=(t.ins_h<<t.hash_shift^t.window[r+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[r+ht-1])&t.hash_mask,t.prev[r&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=r,r++,t.insert--,!(t.lookahead+t.insert<ht)););}while(t.lookahead<ft&&0!==t.strm.avail_in)}function u(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(_(t),0===t.lookahead&&e===I)return vt;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+a;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,o(t,!1),0===t.strm.avail_out))return vt;if(t.strstart-t.block_start>=t.w_size-ft&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.strstart>t.block_start&&(o(t,!1),0===t.strm.avail_out)?vt:vt}function c(t,e){for(var a,i;;){if(t.lookahead<ft){if(_(t),t.lookahead<ft&&e===I)return vt;if(0===t.lookahead)break}if(a=0,t.lookahead>=ht&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-ft&&(t.match_length=f(t,a)),t.match_length>=ht)if(i=C._tr_tally(t,t.strstart-t.match_start,t.match_length-ht),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=ht){t.match_length--;do t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart;while(0!==--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=t.strstart<ht-1?t.strstart:ht-1,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function b(t,e){for(var a,i,n;;){if(t.lookahead<ft){if(_(t),t.lookahead<ft&&e===I)return vt;if(0===t.lookahead)break}if(a=0,t.lookahead>=ht&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=ht-1,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-ft&&(t.match_length=f(t,a),t.match_length<=5&&(t.strategy===q||t.match_length===ht&&t.strstart-t.match_start>4096)&&(t.match_length=ht-1)),t.prev_length>=ht&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-ht,i=C._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-ht),t.lookahead-=t.prev_length-1,t.prev_length-=2;do++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart);while(0!==--t.prev_length);if(t.match_available=0,t.match_length=ht-1,t.strstart++,i&&(o(t,!1),0===t.strm.avail_out))return vt}else if(t.match_available){if(i=C._tr_tally(t,0,t.window[t.strstart-1]),i&&o(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return vt}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=C._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<ht-1?t.strstart:ht-1,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function g(t,e){for(var a,i,n,r,s=t.window;;){if(t.lookahead<=dt){if(_(t),t.lookahead<=dt&&e===I)return vt;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=ht&&t.strstart>0&&(n=t.strstart-1,i=s[n],i===s[++n]&&i===s[++n]&&i===s[++n])){r=t.strstart+dt;do;while(i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&n<r);t.match_length=dt-(r-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=ht?(a=C._tr_tally(t,1,t.match_length-ht),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function m(t,e){for(var a;;){if(0===t.lookahead&&(_(t),0===t.lookahead)){if(e===I)return vt;break}if(t.match_length=0,a=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function w(t,e,a,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=i,this.func=n}function p(t){t.window_size=2*t.w_size,r(t.head),t.max_lazy_match=Z[t.level].max_lazy,t.good_match=Z[t.level].good_length,t.nice_match=Z[t.level].nice_length,t.max_chain_length=Z[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=ht-1,t.match_available=0,t.ins_h=0}function v(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=V,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new R.Buf16(2*ot),this.dyn_dtree=new R.Buf16(2*(2*rt+1)),this.bl_tree=new R.Buf16(2*(2*st+1)),r(this.dyn_ltree),r(this.dyn_dtree),r(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new R.Buf16(lt+1),this.heap=new R.Buf16(2*nt+1),r(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new R.Buf16(2*nt+1),r(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function k(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=Q,e=t.state,e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?ut:wt,t.adler=2===e.wrap?0:1,e.last_flush=I,C._tr_init(e),H):i(t,K)}function y(t){var e=k(t);return e===H&&p(t.state),e}function x(t,e){return t&&t.state?2!==t.state.wrap?K:(t.state.gzhead=e,H):K}function z(t,e,a,n,r,s){if(!t)return K;var o=1;if(e===Y&&(e=6),n<0?(o=0,n=-n):n>15&&(o=2,n-=16),r<1||r>$||a!==V||n<8||n>15||e<0||e>9||s<0||s>W)return i(t,K);8===n&&(n=9);var l=new v;return t.state=l,l.strm=t,l.wrap=o,l.gzhead=null,l.w_bits=n,l.w_size=1<<l.w_bits,l.w_mask=l.w_size-1,l.hash_bits=r+7,l.hash_size=1<<l.hash_bits,l.hash_mask=l.hash_size-1,l.hash_shift=~~((l.hash_bits+ht-1)/ht),l.window=new R.Buf8(2*l.w_size),l.head=new R.Buf16(l.hash_size),l.prev=new R.Buf16(l.w_size),l.lit_bufsize=1<<r+6,l.pending_buf_size=4*l.lit_bufsize,l.pending_buf=new R.Buf8(l.pending_buf_size),l.d_buf=1*l.lit_bufsize,l.l_buf=3*l.lit_bufsize,l.level=e,l.strategy=s,l.method=a,y(t)}function B(t,e){return z(t,e,V,tt,et,J)}function S(t,e){var a,o,d,f;if(!t||!t.state||e>L||e<0)return t?i(t,K):K;if(o=t.state,!t.output||!t.input&&0!==t.avail_in||o.status===pt&&e!==F)return i(t,0===t.avail_out?P:K);if(o.strm=t,a=o.last_flush,o.last_flush=e,o.status===ut)if(2===o.wrap)t.adler=0,l(o,31),l(o,139),l(o,8),o.gzhead?(l(o,(o.gzhead.text?1:0)+(o.gzhead.hcrc?2:0)+(o.gzhead.extra?4:0)+(o.gzhead.name?8:0)+(o.gzhead.comment?16:0)),l(o,255&o.gzhead.time),l(o,o.gzhead.time>>8&255),l(o,o.gzhead.time>>16&255),l(o,o.gzhead.time>>24&255),l(o,9===o.level?2:o.strategy>=G||o.level<2?4:0),l(o,255&o.gzhead.os),o.gzhead.extra&&o.gzhead.extra.length&&(l(o,255&o.gzhead.extra.length),l(o,o.gzhead.extra.length>>8&255)),o.gzhead.hcrc&&(t.adler=O(t.adler,o.pending_buf,o.pending,0)),o.gzindex=0,o.status=ct):(l(o,0),l(o,0),l(o,0),l(o,0),l(o,0),l(o,9===o.level?2:o.strategy>=G||o.level<2?4:0),l(o,zt),o.status=wt);else{var _=V+(o.w_bits-8<<4)<<8,u=-1;u=o.strategy>=G||o.level<2?0:o.level<6?1:6===o.level?2:3,_|=u<<6,0!==o.strstart&&(_|=_t),_+=31-_%31,o.status=wt,h(o,_),0!==o.strstart&&(h(o,t.adler>>>16),h(o,65535&t.adler)),t.adler=1}if(o.status===ct)if(o.gzhead.extra){for(d=o.pending;o.gzindex<(65535&o.gzhead.extra.length)&&(o.pending!==o.pending_buf_size||(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending!==o.pending_buf_size));)l(o,255&o.gzhead.extra[o.gzindex]),o.gzindex++;o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),o.gzindex===o.gzhead.extra.length&&(o.gzindex=0,o.status=bt)}else o.status=bt;if(o.status===bt)if(o.gzhead.name){d=o.pending;do{if(o.pending===o.pending_buf_size&&(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending===o.pending_buf_size)){f=1;break}f=o.gzindex<o.gzhead.name.length?255&o.gzhead.name.charCodeAt(o.gzindex++):0,l(o,f)}while(0!==f);o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),0===f&&(o.gzindex=0,o.status=gt)}else o.status=gt;if(o.status===gt)if(o.gzhead.comment){d=o.pending;do{if(o.pending===o.pending_buf_size&&(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending===o.pending_buf_size)){f=1;break}f=o.gzindex<o.gzhead.comment.length?255&o.gzhead.comment.charCodeAt(o.gzindex++):0,l(o,f)}while(0!==f);o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),0===f&&(o.status=mt)}else o.status=mt;if(o.status===mt&&(o.gzhead.hcrc?(o.pending+2>o.pending_buf_size&&s(t),o.pending+2<=o.pending_buf_size&&(l(o,255&t.adler),l(o,t.adler>>8&255),t.adler=0,o.status=wt)):o.status=wt),0!==o.pending){if(s(t),0===t.avail_out)return o.last_flush=-1,H}else if(0===t.avail_in&&n(e)<=n(a)&&e!==F)return i(t,P);if(o.status===pt&&0!==t.avail_in)return i(t,P);if(0!==t.avail_in||0!==o.lookahead||e!==I&&o.status!==pt){var c=o.strategy===G?m(o,e):o.strategy===X?g(o,e):Z[o.level].func(o,e);if(c!==yt&&c!==xt||(o.status=pt),c===vt||c===yt)return 0===t.avail_out&&(o.last_flush=-1),H;if(c===kt&&(e===U?C._tr_align(o):e!==L&&(C._tr_stored_block(o,0,0,!1),e===T&&(r(o.head),0===o.lookahead&&(o.strstart=0,o.block_start=0,o.insert=0))),s(t),0===t.avail_out))return o.last_flush=-1,H}return e!==F?H:o.wrap<=0?j:(2===o.wrap?(l(o,255&t.adler),l(o,t.adler>>8&255),l(o,t.adler>>16&255),l(o,t.adler>>24&255),l(o,255&t.total_in),l(o,t.total_in>>8&255),l(o,t.total_in>>16&255),l(o,t.total_in>>24&255)):(h(o,t.adler>>>16),h(o,65535&t.adler)),s(t),o.wrap>0&&(o.wrap=-o.wrap),0!==o.pending?H:j)}function E(t){var e;return t&&t.state?(e=t.state.status,e!==ut&&e!==ct&&e!==bt&&e!==gt&&e!==mt&&e!==wt&&e!==pt?i(t,K):(t.state=null,e===wt?i(t,M):H)):K}function A(t,e){var a,i,n,s,o,l,h,d,f=e.length;if(!t||!t.state)return K;if(a=t.state,s=a.wrap,2===s||1===s&&a.status!==ut||a.lookahead)return K;for(1===s&&(t.adler=N(t.adler,e,f,0)),a.wrap=0,f>=a.w_size&&(0===s&&(r(a.head),a.strstart=0,a.block_start=0,a.insert=0),d=new R.Buf8(a.w_size),R.arraySet(d,e,f-a.w_size,a.w_size,0),e=d,f=a.w_size),o=t.avail_in,l=t.next_in,h=t.input,t.avail_in=f,t.next_in=0,t.input=e,_(a);a.lookahead>=ht;){i=a.strstart,n=a.lookahead-(ht-1);do a.ins_h=(a.ins_h<<a.hash_shift^a.window[i+ht-1])&a.hash_mask,a.prev[i&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=i,i++;while(--n);a.strstart=i,a.lookahead=ht-1,_(a)}return a.strstart+=a.lookahead,a.block_start=a.strstart,a.insert=a.lookahead,a.lookahead=0,a.match_length=a.prev_length=ht-1,a.match_available=0,t.next_in=l,t.input=h,t.avail_in=o,a.wrap=s,H}var Z,R=t(\"../utils/common\"),C=t(\"./trees\"),N=t(\"./adler32\"),O=t(\"./crc32\"),D=t(\"./messages\"),I=0,U=1,T=3,F=4,L=5,H=0,j=1,K=-2,M=-3,P=-5,Y=-1,q=1,G=2,X=3,W=4,J=0,Q=2,V=8,$=9,tt=15,et=8,at=29,it=256,nt=it+1+at,rt=30,st=19,ot=2*nt+1,lt=15,ht=3,dt=258,ft=dt+ht+1,_t=32,ut=42,ct=69,bt=73,gt=91,mt=103,wt=113,pt=666,vt=1,kt=2,yt=3,xt=4,zt=3;Z=[new w(0,0,0,0,u),new w(4,4,8,4,c),new w(4,5,16,8,c),new w(4,6,32,32,c),new w(4,4,16,16,b),new w(8,16,32,32,b),new w(8,16,128,128,b),new w(8,32,128,256,b),new w(32,128,258,1024,b),new w(32,258,258,4096,b)],a.deflateInit=B,a.deflateInit2=z,a.deflateReset=y,a.deflateResetKeep=k,a.deflateSetHeader=x,a.deflate=S,a.deflateEnd=E,a.deflateSetDictionary=A,a.deflateInfo=\"pako deflate (from Nodeca project)\"},{\"../utils/common\":3,\"./adler32\":5,\"./crc32\":7,\"./messages\":13,\"./trees\":14}],9:[function(t,e,a){\"use strict\";function i(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}e.exports=i},{}],10:[function(t,e,a){\"use strict\";var i=30,n=12;e.exports=function(t,e){var a,r,s,o,l,h,d,f,_,u,c,b,g,m,w,p,v,k,y,x,z,B,S,E,A;a=t.state,r=t.next_in,E=t.input,s=r+(t.avail_in-5),o=t.next_out,A=t.output,l=o-(e-t.avail_out),h=o+(t.avail_out-257),d=a.dmax,f=a.wsize,_=a.whave,u=a.wnext,c=a.window,b=a.hold,g=a.bits,m=a.lencode,w=a.distcode,p=(1<<a.lenbits)-1,v=(1<<a.distbits)-1;t:do{g<15&&(b+=E[r++]<<g,g+=8,b+=E[r++]<<g,g+=8),k=m[b&p];e:for(;;){if(y=k>>>24,b>>>=y,g-=y,y=k>>>16&255,0===y)A[o++]=65535&k;else{if(!(16&y)){if(0===(64&y)){k=m[(65535&k)+(b&(1<<y)-1)];continue e}if(32&y){a.mode=n;break t}t.msg=\"invalid literal/length code\",a.mode=i;break t}x=65535&k,y&=15,y&&(g<y&&(b+=E[r++]<<g,g+=8),x+=b&(1<<y)-1,b>>>=y,g-=y),g<15&&(b+=E[r++]<<g,g+=8,b+=E[r++]<<g,g+=8),k=w[b&v];a:for(;;){if(y=k>>>24,b>>>=y,g-=y,y=k>>>16&255,!(16&y)){if(0===(64&y)){k=w[(65535&k)+(b&(1<<y)-1)];continue a}t.msg=\"invalid distance code\",a.mode=i;break t}if(z=65535&k,y&=15,g<y&&(b+=E[r++]<<g,g+=8,g<y&&(b+=E[r++]<<g,g+=8)),z+=b&(1<<y)-1,z>d){t.msg=\"invalid distance too far back\",a.mode=i;break t}if(b>>>=y,g-=y,y=o-l,z>y){if(y=z-y,y>_&&a.sane){t.msg=\"invalid distance too far back\",a.mode=i;break t}if(B=0,S=c,0===u){if(B+=f-y,y<x){x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}}else if(u<y){if(B+=f+u-y,y-=u,y<x){x-=y;do A[o++]=c[B++];while(--y);if(B=0,u<x){y=u,x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}}}else if(B+=u-y,y<x){x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}for(;x>2;)A[o++]=S[B++],A[o++]=S[B++],A[o++]=S[B++],x-=3;x&&(A[o++]=S[B++],x>1&&(A[o++]=S[B++]))}else{B=o-z;do A[o++]=A[B++],A[o++]=A[B++],A[o++]=A[B++],x-=3;while(x>2);x&&(A[o++]=A[B++],x>1&&(A[o++]=A[B++]))}break}}break}}while(r<s&&o<h);x=g>>3,r-=x,g-=x<<3,b&=(1<<g)-1,t.next_in=r,t.next_out=o,t.avail_in=r<s?5+(s-r):5-(r-s),t.avail_out=o<h?257+(h-o):257-(o-h),a.hold=b,a.bits=g}},{}],11:[function(t,e,a){\"use strict\";function i(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function n(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new w.Buf16(320),this.work=new w.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function r(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg=\"\",e.wrap&&(t.adler=1&e.wrap),e.mode=T,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new w.Buf32(bt),e.distcode=e.distdyn=new w.Buf32(gt),e.sane=1,e.back=-1,Z):N}function s(t){var e;return t&&t.state?(e=t.state,e.wsize=0,e.whave=0,e.wnext=0,r(t)):N}function o(t,e){var a,i;return t&&t.state?(i=t.state,e<0?(a=0,e=-e):(a=(e>>4)+1,e<48&&(e&=15)),e&&(e<8||e>15)?N:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=a,i.wbits=e,s(t))):N}function l(t,e){var a,i;return t?(i=new n,t.state=i,i.window=null,a=o(t,e),a!==Z&&(t.state=null),a):N}function h(t){return l(t,wt)}function d(t){if(pt){var e;for(g=new w.Buf32(512),m=new w.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(y(z,t.lens,0,288,g,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;y(B,t.lens,0,32,m,0,t.work,{bits:5}),pt=!1}t.lencode=g,t.lenbits=9,t.distcode=m,t.distbits=5}function f(t,e,a,i){var n,r=t.state;return null===r.window&&(r.wsize=1<<r.wbits,r.wnext=0,r.whave=0,r.window=new w.Buf8(r.wsize)),i>=r.wsize?(w.arraySet(r.window,e,a-r.wsize,r.wsize,0),r.wnext=0,r.whave=r.wsize):(n=r.wsize-r.wnext,n>i&&(n=i),w.arraySet(r.window,e,a-i,n,r.wnext),i-=n,i?(w.arraySet(r.window,e,a-i,i,0),r.wnext=i,r.whave=r.wsize):(r.wnext+=n,r.wnext===r.wsize&&(r.wnext=0),r.whave<r.wsize&&(r.whave+=n))),0}function _(t,e){var a,n,r,s,o,l,h,_,u,c,b,g,m,bt,gt,mt,wt,pt,vt,kt,yt,xt,zt,Bt,St=0,Et=new w.Buf8(4),At=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return N;a=t.state,a.mode===X&&(a.mode=W),o=t.next_out,r=t.output,h=t.avail_out,s=t.next_in,n=t.input,l=t.avail_in,_=a.hold,u=a.bits,c=l,b=h,xt=Z;t:for(;;)switch(a.mode){case T:if(0===a.wrap){a.mode=W;break}for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(2&a.wrap&&35615===_){a.check=0,Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0),_=0,u=0,a.mode=F;break}if(a.flags=0,a.head&&(a.head.done=!1),!(1&a.wrap)||(((255&_)<<8)+(_>>8))%31){t.msg=\"incorrect header check\",a.mode=_t;break}if((15&_)!==U){t.msg=\"unknown compression method\",a.mode=_t;break}if(_>>>=4,u-=4,yt=(15&_)+8,0===a.wbits)a.wbits=yt;else if(yt>a.wbits){t.msg=\"invalid window size\",a.mode=_t;break}a.dmax=1<<yt,t.adler=a.check=1,a.mode=512&_?q:X,_=0,u=0;break;case F:for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(a.flags=_,(255&a.flags)!==U){t.msg=\"unknown compression method\",a.mode=_t;break}if(57344&a.flags){t.msg=\"unknown header flags set\",a.mode=_t;break}a.head&&(a.head.text=_>>8&1),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0,a.mode=L;case L:for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.head&&(a.head.time=_),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,Et[2]=_>>>16&255,Et[3]=_>>>24&255,a.check=v(a.check,Et,4,0)),_=0,u=0,a.mode=H;case H:for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.head&&(a.head.xflags=255&_,a.head.os=_>>8),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0,a.mode=j;case j:if(1024&a.flags){for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.length=_,a.head&&(a.head.extra_len=_),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0}else a.head&&(a.head.extra=null);a.mode=K;case K:if(1024&a.flags&&(g=a.length,g>l&&(g=l),g&&(a.head&&(yt=a.head.extra_len-a.length,a.head.extra||(a.head.extra=new Array(a.head.extra_len)),w.arraySet(a.head.extra,n,s,g,yt)),512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,a.length-=g),a.length))break t;a.length=0,a.mode=M;case M:if(2048&a.flags){if(0===l)break t;g=0;do yt=n[s+g++],a.head&&yt&&a.length<65536&&(a.head.name+=String.fromCharCode(yt));while(yt&&g<l);if(512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,yt)break t}else a.head&&(a.head.name=null);a.length=0,a.mode=P;case P:if(4096&a.flags){if(0===l)break t;g=0;do yt=n[s+g++],a.head&&yt&&a.length<65536&&(a.head.comment+=String.fromCharCode(yt));while(yt&&g<l);if(512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,yt)break t}else a.head&&(a.head.comment=null);a.mode=Y;case Y:if(512&a.flags){for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_!==(65535&a.check)){t.msg=\"header crc mismatch\",a.mode=_t;break}_=0,u=0}a.head&&(a.head.hcrc=a.flags>>9&1,a.head.done=!0),t.adler=a.check=0,a.mode=X;break;case q:for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}t.adler=a.check=i(_),_=0,u=0,a.mode=G;case G:if(0===a.havedict)return t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,C;t.adler=a.check=1,a.mode=X;case X:if(e===E||e===A)break t;case W:if(a.last){_>>>=7&u,u-=7&u,a.mode=ht;break}for(;u<3;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}switch(a.last=1&_,_>>>=1,u-=1,3&_){case 0:a.mode=J;break;case 1:if(d(a),a.mode=at,e===A){_>>>=2,u-=2;break t}break;case 2:a.mode=$;break;case 3:t.msg=\"invalid block type\",a.mode=_t}_>>>=2,u-=2;break;case J:for(_>>>=7&u,u-=7&u;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if((65535&_)!==(_>>>16^65535)){t.msg=\"invalid stored block lengths\",a.mode=_t;break}if(a.length=65535&_,_=0,u=0,a.mode=Q,e===A)break t;case Q:a.mode=V;case V:if(g=a.length){if(g>l&&(g=l),g>h&&(g=h),0===g)break t;w.arraySet(r,n,s,g,o),l-=g,s+=g,h-=g,o+=g,a.length-=g;break}a.mode=X;break;case $:\nfor(;u<14;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(a.nlen=(31&_)+257,_>>>=5,u-=5,a.ndist=(31&_)+1,_>>>=5,u-=5,a.ncode=(15&_)+4,_>>>=4,u-=4,a.nlen>286||a.ndist>30){t.msg=\"too many length or distance symbols\",a.mode=_t;break}a.have=0,a.mode=tt;case tt:for(;a.have<a.ncode;){for(;u<3;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.lens[At[a.have++]]=7&_,_>>>=3,u-=3}for(;a.have<19;)a.lens[At[a.have++]]=0;if(a.lencode=a.lendyn,a.lenbits=7,zt={bits:a.lenbits},xt=y(x,a.lens,0,19,a.lencode,0,a.work,zt),a.lenbits=zt.bits,xt){t.msg=\"invalid code lengths set\",a.mode=_t;break}a.have=0,a.mode=et;case et:for(;a.have<a.nlen+a.ndist;){for(;St=a.lencode[_&(1<<a.lenbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(wt<16)_>>>=gt,u-=gt,a.lens[a.have++]=wt;else{if(16===wt){for(Bt=gt+2;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_>>>=gt,u-=gt,0===a.have){t.msg=\"invalid bit length repeat\",a.mode=_t;break}yt=a.lens[a.have-1],g=3+(3&_),_>>>=2,u-=2}else if(17===wt){for(Bt=gt+3;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=gt,u-=gt,yt=0,g=3+(7&_),_>>>=3,u-=3}else{for(Bt=gt+7;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=gt,u-=gt,yt=0,g=11+(127&_),_>>>=7,u-=7}if(a.have+g>a.nlen+a.ndist){t.msg=\"invalid bit length repeat\",a.mode=_t;break}for(;g--;)a.lens[a.have++]=yt}}if(a.mode===_t)break;if(0===a.lens[256]){t.msg=\"invalid code -- missing end-of-block\",a.mode=_t;break}if(a.lenbits=9,zt={bits:a.lenbits},xt=y(z,a.lens,0,a.nlen,a.lencode,0,a.work,zt),a.lenbits=zt.bits,xt){t.msg=\"invalid literal/lengths set\",a.mode=_t;break}if(a.distbits=6,a.distcode=a.distdyn,zt={bits:a.distbits},xt=y(B,a.lens,a.nlen,a.ndist,a.distcode,0,a.work,zt),a.distbits=zt.bits,xt){t.msg=\"invalid distances set\",a.mode=_t;break}if(a.mode=at,e===A)break t;case at:a.mode=it;case it:if(l>=6&&h>=258){t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,k(t,b),o=t.next_out,r=t.output,h=t.avail_out,s=t.next_in,n=t.input,l=t.avail_in,_=a.hold,u=a.bits,a.mode===X&&(a.back=-1);break}for(a.back=0;St=a.lencode[_&(1<<a.lenbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(mt&&0===(240&mt)){for(pt=gt,vt=mt,kt=wt;St=a.lencode[kt+((_&(1<<pt+vt)-1)>>pt)],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(pt+gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=pt,u-=pt,a.back+=pt}if(_>>>=gt,u-=gt,a.back+=gt,a.length=wt,0===mt){a.mode=lt;break}if(32&mt){a.back=-1,a.mode=X;break}if(64&mt){t.msg=\"invalid literal/length code\",a.mode=_t;break}a.extra=15&mt,a.mode=nt;case nt:if(a.extra){for(Bt=a.extra;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.length+=_&(1<<a.extra)-1,_>>>=a.extra,u-=a.extra,a.back+=a.extra}a.was=a.length,a.mode=rt;case rt:for(;St=a.distcode[_&(1<<a.distbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(0===(240&mt)){for(pt=gt,vt=mt,kt=wt;St=a.distcode[kt+((_&(1<<pt+vt)-1)>>pt)],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(pt+gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=pt,u-=pt,a.back+=pt}if(_>>>=gt,u-=gt,a.back+=gt,64&mt){t.msg=\"invalid distance code\",a.mode=_t;break}a.offset=wt,a.extra=15&mt,a.mode=st;case st:if(a.extra){for(Bt=a.extra;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.offset+=_&(1<<a.extra)-1,_>>>=a.extra,u-=a.extra,a.back+=a.extra}if(a.offset>a.dmax){t.msg=\"invalid distance too far back\",a.mode=_t;break}a.mode=ot;case ot:if(0===h)break t;if(g=b-h,a.offset>g){if(g=a.offset-g,g>a.whave&&a.sane){t.msg=\"invalid distance too far back\",a.mode=_t;break}g>a.wnext?(g-=a.wnext,m=a.wsize-g):m=a.wnext-g,g>a.length&&(g=a.length),bt=a.window}else bt=r,m=o-a.offset,g=a.length;g>h&&(g=h),h-=g,a.length-=g;do r[o++]=bt[m++];while(--g);0===a.length&&(a.mode=it);break;case lt:if(0===h)break t;r[o++]=a.length,h--,a.mode=it;break;case ht:if(a.wrap){for(;u<32;){if(0===l)break t;l--,_|=n[s++]<<u,u+=8}if(b-=h,t.total_out+=b,a.total+=b,b&&(t.adler=a.check=a.flags?v(a.check,r,b,o-b):p(a.check,r,b,o-b)),b=h,(a.flags?_:i(_))!==a.check){t.msg=\"incorrect data check\",a.mode=_t;break}_=0,u=0}a.mode=dt;case dt:if(a.wrap&&a.flags){for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_!==(4294967295&a.total)){t.msg=\"incorrect length check\",a.mode=_t;break}_=0,u=0}a.mode=ft;case ft:xt=R;break t;case _t:xt=O;break t;case ut:return D;case ct:default:return N}return t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,(a.wsize||b!==t.avail_out&&a.mode<_t&&(a.mode<ht||e!==S))&&f(t,t.output,t.next_out,b-t.avail_out)?(a.mode=ut,D):(c-=t.avail_in,b-=t.avail_out,t.total_in+=c,t.total_out+=b,a.total+=b,a.wrap&&b&&(t.adler=a.check=a.flags?v(a.check,r,b,t.next_out-b):p(a.check,r,b,t.next_out-b)),t.data_type=a.bits+(a.last?64:0)+(a.mode===X?128:0)+(a.mode===at||a.mode===Q?256:0),(0===c&&0===b||e===S)&&xt===Z&&(xt=I),xt)}function u(t){if(!t||!t.state)return N;var e=t.state;return e.window&&(e.window=null),t.state=null,Z}function c(t,e){var a;return t&&t.state?(a=t.state,0===(2&a.wrap)?N:(a.head=e,e.done=!1,Z)):N}function b(t,e){var a,i,n,r=e.length;return t&&t.state?(a=t.state,0!==a.wrap&&a.mode!==G?N:a.mode===G&&(i=1,i=p(i,e,r,0),i!==a.check)?O:(n=f(t,e,r,r))?(a.mode=ut,D):(a.havedict=1,Z)):N}var g,m,w=t(\"../utils/common\"),p=t(\"./adler32\"),v=t(\"./crc32\"),k=t(\"./inffast\"),y=t(\"./inftrees\"),x=0,z=1,B=2,S=4,E=5,A=6,Z=0,R=1,C=2,N=-2,O=-3,D=-4,I=-5,U=8,T=1,F=2,L=3,H=4,j=5,K=6,M=7,P=8,Y=9,q=10,G=11,X=12,W=13,J=14,Q=15,V=16,$=17,tt=18,et=19,at=20,it=21,nt=22,rt=23,st=24,ot=25,lt=26,ht=27,dt=28,ft=29,_t=30,ut=31,ct=32,bt=852,gt=592,mt=15,wt=mt,pt=!0;a.inflateReset=s,a.inflateReset2=o,a.inflateResetKeep=r,a.inflateInit=h,a.inflateInit2=l,a.inflate=_,a.inflateEnd=u,a.inflateGetHeader=c,a.inflateSetDictionary=b,a.inflateInfo=\"pako inflate (from Nodeca project)\"},{\"../utils/common\":3,\"./adler32\":5,\"./crc32\":7,\"./inffast\":10,\"./inftrees\":12}],12:[function(t,e,a){\"use strict\";var i=t(\"../utils/common\"),n=15,r=852,s=592,o=0,l=1,h=2,d=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],f=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],_=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],u=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,a,c,b,g,m,w){var p,v,k,y,x,z,B,S,E,A=w.bits,Z=0,R=0,C=0,N=0,O=0,D=0,I=0,U=0,T=0,F=0,L=null,H=0,j=new i.Buf16(n+1),K=new i.Buf16(n+1),M=null,P=0;for(Z=0;Z<=n;Z++)j[Z]=0;for(R=0;R<c;R++)j[e[a+R]]++;for(O=A,N=n;N>=1&&0===j[N];N--);if(O>N&&(O=N),0===N)return b[g++]=20971520,b[g++]=20971520,w.bits=1,0;for(C=1;C<N&&0===j[C];C++);for(O<C&&(O=C),U=1,Z=1;Z<=n;Z++)if(U<<=1,U-=j[Z],U<0)return-1;if(U>0&&(t===o||1!==N))return-1;for(K[1]=0,Z=1;Z<n;Z++)K[Z+1]=K[Z]+j[Z];for(R=0;R<c;R++)0!==e[a+R]&&(m[K[e[a+R]]++]=R);if(t===o?(L=M=m,z=19):t===l?(L=d,H-=257,M=f,P-=257,z=256):(L=_,M=u,z=-1),F=0,R=0,Z=C,x=g,D=O,I=0,k=-1,T=1<<O,y=T-1,t===l&&T>r||t===h&&T>s)return 1;for(;;){B=Z-I,m[R]<z?(S=0,E=m[R]):m[R]>z?(S=M[P+m[R]],E=L[H+m[R]]):(S=96,E=0),p=1<<Z-I,v=1<<D,C=v;do v-=p,b[x+(F>>I)+v]=B<<24|S<<16|E|0;while(0!==v);for(p=1<<Z-1;F&p;)p>>=1;if(0!==p?(F&=p-1,F+=p):F=0,R++,0===--j[Z]){if(Z===N)break;Z=e[a+m[R]]}if(Z>O&&(F&y)!==k){for(0===I&&(I=O),x+=C,D=Z-I,U=1<<D;D+I<N&&(U-=j[D+I],!(U<=0));)D++,U<<=1;if(T+=1<<D,t===l&&T>r||t===h&&T>s)return 1;k=F&y,b[k]=O<<24|D<<16|x-g|0}}return 0!==F&&(b[x+F]=Z-I<<24|64<<16|0),w.bits=O,0}},{\"../utils/common\":3}],13:[function(t,e,a){\"use strict\";e.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},{}],14:[function(t,e,a){\"use strict\";function i(t){for(var e=t.length;--e>=0;)t[e]=0}function n(t,e,a,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function r(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function s(t){return t<256?lt[t]:lt[256+(t>>>7)]}function o(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function l(t,e,a){t.bi_valid>W-a?(t.bi_buf|=e<<t.bi_valid&65535,o(t,t.bi_buf),t.bi_buf=e>>W-t.bi_valid,t.bi_valid+=a-W):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)}function h(t,e,a){l(t,a[2*e],a[2*e+1])}function d(t,e){var a=0;do a|=1&t,t>>>=1,a<<=1;while(--e>0);return a>>>1}function f(t){16===t.bi_valid?(o(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}function _(t,e){var a,i,n,r,s,o,l=e.dyn_tree,h=e.max_code,d=e.stat_desc.static_tree,f=e.stat_desc.has_stree,_=e.stat_desc.extra_bits,u=e.stat_desc.extra_base,c=e.stat_desc.max_length,b=0;for(r=0;r<=X;r++)t.bl_count[r]=0;for(l[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<G;a++)i=t.heap[a],r=l[2*l[2*i+1]+1]+1,r>c&&(r=c,b++),l[2*i+1]=r,i>h||(t.bl_count[r]++,s=0,i>=u&&(s=_[i-u]),o=l[2*i],t.opt_len+=o*(r+s),f&&(t.static_len+=o*(d[2*i+1]+s)));if(0!==b){do{for(r=c-1;0===t.bl_count[r];)r--;t.bl_count[r]--,t.bl_count[r+1]+=2,t.bl_count[c]--,b-=2}while(b>0);for(r=c;0!==r;r--)for(i=t.bl_count[r];0!==i;)n=t.heap[--a],n>h||(l[2*n+1]!==r&&(t.opt_len+=(r-l[2*n+1])*l[2*n],l[2*n+1]=r),i--)}}function u(t,e,a){var i,n,r=new Array(X+1),s=0;for(i=1;i<=X;i++)r[i]=s=s+a[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=d(r[o]++,o))}}function c(){var t,e,a,i,r,s=new Array(X+1);for(a=0,i=0;i<K-1;i++)for(dt[i]=a,t=0;t<1<<et[i];t++)ht[a++]=i;for(ht[a-1]=i,r=0,i=0;i<16;i++)for(ft[i]=r,t=0;t<1<<at[i];t++)lt[r++]=i;for(r>>=7;i<Y;i++)for(ft[i]=r<<7,t=0;t<1<<at[i]-7;t++)lt[256+r++]=i;for(e=0;e<=X;e++)s[e]=0;for(t=0;t<=143;)st[2*t+1]=8,t++,s[8]++;for(;t<=255;)st[2*t+1]=9,t++,s[9]++;for(;t<=279;)st[2*t+1]=7,t++,s[7]++;for(;t<=287;)st[2*t+1]=8,t++,s[8]++;for(u(st,P+1,s),t=0;t<Y;t++)ot[2*t+1]=5,ot[2*t]=d(t,5);_t=new n(st,et,M+1,P,X),ut=new n(ot,at,0,Y,X),ct=new n(new Array(0),it,0,q,J)}function b(t){var e;for(e=0;e<P;e++)t.dyn_ltree[2*e]=0;for(e=0;e<Y;e++)t.dyn_dtree[2*e]=0;for(e=0;e<q;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*Q]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function g(t){t.bi_valid>8?o(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function m(t,e,a,i){g(t),i&&(o(t,a),o(t,~a)),N.arraySet(t.pending_buf,t.window,e,a,t.pending),t.pending+=a}function w(t,e,a,i){var n=2*e,r=2*a;return t[n]<t[r]||t[n]===t[r]&&i[e]<=i[a]}function p(t,e,a){for(var i=t.heap[a],n=a<<1;n<=t.heap_len&&(n<t.heap_len&&w(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!w(e,i,t.heap[n],t.depth));)t.heap[a]=t.heap[n],a=n,n<<=1;t.heap[a]=i}function v(t,e,a){var i,n,r,o,d=0;if(0!==t.last_lit)do i=t.pending_buf[t.d_buf+2*d]<<8|t.pending_buf[t.d_buf+2*d+1],n=t.pending_buf[t.l_buf+d],d++,0===i?h(t,n,e):(r=ht[n],h(t,r+M+1,e),o=et[r],0!==o&&(n-=dt[r],l(t,n,o)),i--,r=s(i),h(t,r,a),o=at[r],0!==o&&(i-=ft[r],l(t,i,o)));while(d<t.last_lit);h(t,Q,e)}function k(t,e){var a,i,n,r=e.dyn_tree,s=e.stat_desc.static_tree,o=e.stat_desc.has_stree,l=e.stat_desc.elems,h=-1;for(t.heap_len=0,t.heap_max=G,a=0;a<l;a++)0!==r[2*a]?(t.heap[++t.heap_len]=h=a,t.depth[a]=0):r[2*a+1]=0;for(;t.heap_len<2;)n=t.heap[++t.heap_len]=h<2?++h:0,r[2*n]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=s[2*n+1]);for(e.max_code=h,a=t.heap_len>>1;a>=1;a--)p(t,r,a);n=l;do a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],p(t,r,1),i=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=i,r[2*n]=r[2*a]+r[2*i],t.depth[n]=(t.depth[a]>=t.depth[i]?t.depth[a]:t.depth[i])+1,r[2*a+1]=r[2*i+1]=n,t.heap[1]=n++,p(t,r,1);while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],_(t,e),u(r,h,t.bl_count)}function y(t,e,a){var i,n,r=-1,s=e[1],o=0,l=7,h=4;for(0===s&&(l=138,h=3),e[2*(a+1)+1]=65535,i=0;i<=a;i++)n=s,s=e[2*(i+1)+1],++o<l&&n===s||(o<h?t.bl_tree[2*n]+=o:0!==n?(n!==r&&t.bl_tree[2*n]++,t.bl_tree[2*V]++):o<=10?t.bl_tree[2*$]++:t.bl_tree[2*tt]++,o=0,r=n,0===s?(l=138,h=3):n===s?(l=6,h=3):(l=7,h=4))}function x(t,e,a){var i,n,r=-1,s=e[1],o=0,d=7,f=4;for(0===s&&(d=138,f=3),i=0;i<=a;i++)if(n=s,s=e[2*(i+1)+1],!(++o<d&&n===s)){if(o<f){do h(t,n,t.bl_tree);while(0!==--o)}else 0!==n?(n!==r&&(h(t,n,t.bl_tree),o--),h(t,V,t.bl_tree),l(t,o-3,2)):o<=10?(h(t,$,t.bl_tree),l(t,o-3,3)):(h(t,tt,t.bl_tree),l(t,o-11,7));o=0,r=n,0===s?(d=138,f=3):n===s?(d=6,f=3):(d=7,f=4)}}function z(t){var e;for(y(t,t.dyn_ltree,t.l_desc.max_code),y(t,t.dyn_dtree,t.d_desc.max_code),k(t,t.bl_desc),e=q-1;e>=3&&0===t.bl_tree[2*nt[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}function B(t,e,a,i){var n;for(l(t,e-257,5),l(t,a-1,5),l(t,i-4,4),n=0;n<i;n++)l(t,t.bl_tree[2*nt[n]+1],3);x(t,t.dyn_ltree,e-1),x(t,t.dyn_dtree,a-1)}function S(t){var e,a=4093624447;for(e=0;e<=31;e++,a>>>=1)if(1&a&&0!==t.dyn_ltree[2*e])return D;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return I;for(e=32;e<M;e++)if(0!==t.dyn_ltree[2*e])return I;return D}function E(t){bt||(c(),bt=!0),t.l_desc=new r(t.dyn_ltree,_t),t.d_desc=new r(t.dyn_dtree,ut),t.bl_desc=new r(t.bl_tree,ct),t.bi_buf=0,t.bi_valid=0,b(t)}function A(t,e,a,i){l(t,(T<<1)+(i?1:0),3),m(t,e,a,!0)}function Z(t){l(t,F<<1,3),h(t,Q,st),f(t)}function R(t,e,a,i){var n,r,s=0;t.level>0?(t.strm.data_type===U&&(t.strm.data_type=S(t)),k(t,t.l_desc),k(t,t.d_desc),s=z(t),n=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=n&&(n=r)):n=r=a+5,a+4<=n&&e!==-1?A(t,e,a,i):t.strategy===O||r===n?(l(t,(F<<1)+(i?1:0),3),v(t,st,ot)):(l(t,(L<<1)+(i?1:0),3),B(t,t.l_desc.max_code+1,t.d_desc.max_code+1,s+1),v(t,t.dyn_ltree,t.dyn_dtree)),b(t),i&&g(t)}function C(t,e,a){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&a,t.last_lit++,0===e?t.dyn_ltree[2*a]++:(t.matches++,e--,t.dyn_ltree[2*(ht[a]+M+1)]++,t.dyn_dtree[2*s(e)]++),t.last_lit===t.lit_bufsize-1}var N=t(\"../utils/common\"),O=4,D=0,I=1,U=2,T=0,F=1,L=2,H=3,j=258,K=29,M=256,P=M+1+K,Y=30,q=19,G=2*P+1,X=15,W=16,J=7,Q=256,V=16,$=17,tt=18,et=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],at=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],it=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],nt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],rt=512,st=new Array(2*(P+2));i(st);var ot=new Array(2*Y);i(ot);var lt=new Array(rt);i(lt);var ht=new Array(j-H+1);i(ht);var dt=new Array(K);i(dt);var ft=new Array(Y);i(ft);var _t,ut,ct,bt=!1;a._tr_init=E,a._tr_stored_block=A,a._tr_flush_block=R,a._tr_tally=C,a._tr_align=Z},{\"../utils/common\":3}],15:[function(t,e,a){\"use strict\";function i(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}e.exports=i},{}],\"/\":[function(t,e,a){\"use strict\";var i=t(\"./lib/utils/common\").assign,n=t(\"./lib/deflate\"),r=t(\"./lib/inflate\"),s=t(\"./lib/zlib/constants\"),o={};i(o,n,r,s),e.exports=o},{\"./lib/deflate\":1,\"./lib/inflate\":2,\"./lib/utils/common\":3,\"./lib/zlib/constants\":6}]},{},[])(\"/\")});\n"
bitmap_support_ZipSupport.haxeZipCompressJsSupportOnce = False
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
haxe_zip_InflateImpl.FIXED_HUFFMAN = None
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")

Main.main()
